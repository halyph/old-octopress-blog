<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Automation | Knowledge Is Everything]]></title>
  <link href="http://halyph.com/blog/categories/automation/atom.xml" rel="self"/>
  <link href="http://halyph.com/"/>
  <updated>2016-01-09T22:57:29+02:00</updated>
  <id>http://halyph.com/</id>
  <author>
    <name><![CDATA[Orest Ivasiv]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Jenkins Hierarchical Jobs and Jobs Status Aggregation]]></title>
    <link href="http://halyph.com/blog/2013/01/26/jenkins-hierarchical-jobs-and-jobs/"/>
    <updated>2013-01-26T21:00:00+02:00</updated>
    <id>http://halyph.com/blog/2013/01/26/jenkins-hierarchical-jobs-and-jobs</id>
    <content type="html"><![CDATA[<div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-G0y3vRvF8Gk/UODT7t-pUCI/AAAAAAAABF4/JxoydHYGUvQ/s1600/logo.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://3.bp.blogspot.com/-G0y3vRvF8Gk/UODT7t-pUCI/AAAAAAAABF4/JxoydHYGUvQ/s200/logo.png" width="144" /></a></div>


<p><br />As you probably know, Jenkins is highly configurable CI server. We can setup different custom build process. And I&rsquo;m going to share some approach I&rsquo;ve been using to setup the hierarchy of Jenkins&#8217; jobs.<br /><br />Here is use case.<br /><ol><li>We have one main entry job which is invoked to start the whole build process.</li><li>This job can have from one to many child jobs. (Level 2)</li><li>Each child job can have from one to many child jobs, aslo. (Level 3)</li><li>The main idea is to collect/aggregate all children jobs&#8217; status into main entry job.</li></ol>See sample screenshot below which visualize the general idea. Here:<br /><ul><li><b>Main_Job</b> is single entry job, which must contain all sibling jobs&nbsp; statuses</li><li><b>Job_Set_1</b> and <b>Job_Set_2</b> are two child jobs</li><li><b>Build<em>[1-4]</b> are child jobs of <b>Job_Set_1</b></li><li><b>Tests</em>[1-3] </b>are child jobs of <b>Job_Set_2 </b></li></ul><a href="http://4.bp.blogspot.com/-iyHpPeql7yU/UQFNNWFLsLI/AAAAAAAABKk/Brbhqd6gk9Y/s1600/430020a3902e8933e1f5139476c78c54-797242.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5837031483709829298" src="http://4.bp.blogspot.com/-iyHpPeql7yU/UQFNNWFLsLI/AAAAAAAABKk/Brbhqd6gk9Y/s1600/430020a3902e8933e1f5139476c78c54-797242.png" /></a><br /><div><br />Now, we should use some Jenkins plugin to build such hierarchy. I&rsquo;ve been using <a href="https://wiki.jenkins-ci.org/display/JENKINS/Multijob+Plugin">Multijob Plugin</a>.<br />See below screenshots of configuration for:</div><div><span style="font-size: large;">Main_Job/configure</span></div><div></div><div><a href="http://4.bp.blogspot.com/-WyXC1T_3t0M/UQFNNpqidrI/AAAAAAAABKw/uZBnS3t1LGw/s1600/4950bb72552ee19c56670747fb4feabc-798937.png"><img alt="" border="0" height="145" id="BLOGGER_PHOTO_ID_5837031488966784690" src="http://4.bp.blogspot.com/-WyXC1T_3t0M/UQFNNpqidrI/AAAAAAAABKw/uZBnS3t1LGw/s400/4950bb72552ee19c56670747fb4feabc-798937.png" width="400" /></a></div><div><a href="http://2.bp.blogspot.com/-kPCLajFpuHI/UQFNOasRe_I/AAAAAAAABK8/rz2Gqi2CXHE/s1600/3592f7cb62a895053a2ca28296365cf0-701655.png"></a></div><div></div><div><span style="font-size: large;">Job_Set_1/configure&nbsp;</span></div><div><a href="http://1.bp.blogspot.com/-bqjPK5xNekU/UQFNPNg95TI/AAAAAAAABLI/udksxLQVohU/s1600/48663fb91443c29546a4f87e37e3df65-704190.png"><img alt="" border="0" height="205" id="BLOGGER_PHOTO_ID_5837031515770185010" src="http://1.bp.blogspot.com/-bqjPK5xNekU/UQFNPNg95TI/AAAAAAAABLI/udksxLQVohU/s400/48663fb91443c29546a4f87e37e3df65-704190.png" width="400" /></a></div><div><span style="font-size: large;">Job_Set_2/configure&nbsp;</span></div><div><a href="http://1.bp.blogspot.com/-lw8fkGqZcII/UQFNP0N6_0I/AAAAAAAABLU/cGlZ_d7bZDY/s1600/3213350b99d4ba3cb8deedf7bf6f3e0f-707647.png"><img alt="" border="0" height="216" id="BLOGGER_PHOTO_ID_5837031526159286082" src="http://1.bp.blogspot.com/-lw8fkGqZcII/UQFNP0N6_0I/AAAAAAAABLU/cGlZ_d7bZDY/s400/3213350b99d4ba3cb8deedf7bf6f3e0f-707647.png" width="400" /></a></div><div><br />But, it&rsquo;s not enough. We have to aggregate statuses into <b>Main_Job </b>from all sibling jobs. I&rsquo;ve been using patched <a href="https://wiki.jenkins-ci.org/display/JENKINS/Groovy+Postbuild+Plugin">Groovy Postbuild Plugin</a>. Modified plugin is located here <a href="https://github.com/halyph/groovy-postbuild-plugin"><a href="https://github.com/halyph/groovy-postbuild-plugin">https://github.com/halyph/groovy-postbuild-plugin</a> </a><br /><br />Groovy Postbuild Plugin allows us to write groovy scripts for job&rsquo;s Post-build Actions. This script has access to whole Jenkins environment and can consume functionality of all installed Jenkins plugin:</div><div><a href="http://2.bp.blogspot.com/-kPCLajFpuHI/UQFNOasRe_I/AAAAAAAABK8/rz2Gqi2CXHE/s1600/3592f7cb62a895053a2ca28296365cf0-701655.png"><img alt="" border="0" id="BLOGGER_PHOTO_ID_5837031502127397874" src="http://2.bp.blogspot.com/-kPCLajFpuHI/UQFNOasRe_I/AAAAAAAABK8/rz2Gqi2CXHE/s320/3592f7cb62a895053a2ca28296365cf0-701655.png" /></a><br /><br />Here is the source of this script:<br /><pre class="brush: java;"> <br />import hudson.model.<em><br />import com.tikal.jenkins.plugins.multijob.</em>;<br /><br />void log(msg) {<br />  manager.listener.logger.println(msg)<br />}<br /><br />threshold = Result.SUCCESS<br /><br />void aggregate_results() {<br />    failed = false<br /><br />    mainJob = manager.build.getProject().getName()<br />    job = hudson.model.Hudson.instance.getItem(mainJob)<br /><br />    log &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;<br />    log &ldquo;Aggregated status report&rdquo;<br />    log &ldquo;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&rdquo;<br /><br />    log(&ldquo;${mainJob}    #${manager.build.getNumber()} - ${manager.build.getResult()}&rdquo;)<br /><br />    job.getLastBuild().getSubBuilds().each { subBuild-&gt;<br />      subJob = subBuild.getJobName() <br />      subJobNumber = subBuild.getBuildNumber()<br />      job = hudson.model.Hudson.instance.getItem(subBuild.getJobName())<br />      log &ldquo;${subJob}   #${subJobNumber} - ${job.getLastCompletedBuild().getResult()}&rdquo;<br />      log job.getLastCompletedBuild().getLog()<br /><br />      //println subBuild<br />      dePhaseJob = hudson.model.Hudson.instance.getItem(subBuild.getJobName())<br />      dePhaseJobBuild = dePhaseJob.getBuildByNumber(subBuild.getBuildNumber())<br />      dePhaseJobBuild.getSubBuilds().each { childSubBuild -&gt;<br />        try {<br />            log &ldquo;   ${childSubBuild.jobName}&rdquo;<br /><br />            job = hudson.model.Hudson.instance.getItem(childSubBuild.getJobName())<br />            build = job.getBuildByNumber(childSubBuild.getBuildNumber())<br /><br />            indent = &ldquo;  &rdquo;    <br />            log &ldquo;${indent} #${build.getNumber()}  - ${build.getResult()}&rdquo; <br />            log build.getLog()<br /><br />            if(!failed &amp;&amp; build.getResult().isWorseThan(threshold) ) {<br />              failed = true<br />            }<br />        } catch (Exception e) {    <br />            log(&ldquo;ERROR: ${e.getMessage()}&rdquo;)<br />            failed = true<br />        }<br />      }<br />    }<br /><br />    if(failed) {manager.build.setResult(hudson.model.Result.FAILURE)}<br />}<br /><br />try {<br />  aggregate_results()<br />} catch(Exception e) {<br />  log(&ldquo;ERROR: ${e.message}&rdquo;)<br />  log(&ldquo;ERROR: Failed Status report aggregation&rdquo;)<br />  manager.build.setResult(hudson.model.Result.FAILURE)<br />}<br /></pre><br />You can find it on GitHub Gist also: <a href="https://gist.github.com/4610274"><a href="https://gist.github.com/4610274">https://gist.github.com/4610274</a></a>.</div><div>This script is pretty dumb. It simply extracts (prints in Main_Job console) the next info for each child jobs:<br /><ul><li>job name</li><li>build nubmer</li><li>build result (status)</li><li>build log</li></ul>Also, it has ability to set the <b>Main_Job</b> status based on statuses of child jobs. See <code>threshold</code> variable in script.<br /><ul></ul>And aggregated report looks like this:<br /><pre class="brush: bash;">Started by user anonymous<br />Building in workspace C:\Users\oivasiv.jenkins\jobs\Main_Job\workspace<br />Starting build job Job_Set_1.<br />Finished Build : #8 of Job : Job_Set_1 with status :SUCCESS<br />Starting build job Job_Set_2.<br />Finished Build : #8 of Job : Job_Set_2 with status :SUCCESS<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />Aggregated status report<br />&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;<br />Main_Job    #8 - SUCCESS<br />Job_Set_1   #8 - SUCCESS<br />Started by upstream project &ldquo;Main_Job&rdquo; build number 8<br />Building in workspace C:\Users\oivasiv.jenkins\jobs\Job_Set_1\workspace<br />Starting build job Build_1.<br />Starting build job Build_2.<br />Finished Build : #8 of Job : Build_1 with status :FAILURE<br />Finished Build : #8 of Job : Build_2 with status :SUCCESS<br />Starting build job Build_3.<br />Starting build job Build_4.<br />Finished Build : #6 of Job : Build_3 with status :UNSTABLE<br />Finished Build : #6 of Job : Build_4 with status :SUCCESS<br />Notifying upstream projects of job completion<br />Finished: SUCCESS<br /><br />   Build_1<br />   #8  - FAILURE<br />Started by upstream project &ldquo;Job_Set_1&rdquo; build number 8<br />Building in workspace C:\Users\oivasiv.jenkins\jobs\Build_1\workspace<br />Setting result to [Failed]<br />Build step &lsquo;Set the build result&rsquo; changed build result to FAILURE<br />Build step &lsquo;Set the build result&rsquo; marked build as failure<br />Notifying upstream projects of job completion<br />Finished: FAILURE<br /><br />   Build_2<br />   #8  - SUCCESS<br />Started by upstream project &ldquo;Job_Set_1&rdquo; build number 8<br />Building in workspace C:\Users\oivasiv.jenkins\jobs\Build_2\workspace<br />Setting result to [Success]<br />Build step &lsquo;Set the build result&rsquo; changed build result to SUCCESS<br />&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br />null<br />Notifying upstream projects of job completion<br />Finished: SUCCESS<br /><br />   Build_3<br />   #6  - UNSTABLE<br />Started by upstream project &ldquo;Job_Set_1&rdquo; build number 8<br />Building in workspace C:\Users\oivasiv.jenkins\jobs\Build_3\workspace<br />Setting result to [Unstable]<br />Build step &lsquo;Set the build result&rsquo; changed build result to UNSTABLE<br />Notifying upstream projects of job completion<br />Finished: UNSTABLE<br /><br />   Build_4<br />   #6  - SUCCESS<br />Started by upstream project &ldquo;Job_Set_1&rdquo; build number 8<br />Building in workspace C:\Users\oivasiv.jenkins\jobs\Build_4\workspace<br />Setting result to [Success]<br />Build step &lsquo;Set the build result&rsquo; changed build result to SUCCESS<br />Notifying upstream projects of job completion<br />Finished: SUCCESS<br /><br />Job_Set_2   #8 - SUCCESS<br />Started by upstream project &ldquo;Main_Job&rdquo; build number 8<br />Building in workspace C:\Users\oivasiv.jenkins\jobs\Job_Set_2\workspace<br />Starting build job Test_1.<br />Finished Build : #8 of Job : Test_1 with status :SUCCESS<br />Starting build job Test_2.<br />Finished Build : #8 of Job : Test_2 with status :UNSTABLE<br />Starting build job Test_3.<br />Finished Build : #8 of Job : Test_3 with status :SUCCESS<br />Notifying upstream projects of job completion<br />Finished: SUCCESS<br /><br />   Test_1<br />   #8  - SUCCESS<br />Started by upstream project &ldquo;Job_Set_2&rdquo; build number 8<br />Building in workspace C:\Users\oivasiv.jenkins\jobs\Test_1\workspace<br />Setting result to [Success]<br />Build step &lsquo;Set the build result&rsquo; changed build result to SUCCESS<br />Notifying upstream projects of job completion<br />Finished: SUCCESS<br /><br />   Test_2<br />   #8  - UNSTABLE<br />Started by upstream project &ldquo;Job_Set_2&rdquo; build number 8<br />Building in workspace C:\Users\oivasiv.jenkins\jobs\Test_2\workspace<br />Setting result to [Unstable]<br />Build step &lsquo;Set the build result&rsquo; changed build result to UNSTABLE<br />Notifying upstream projects of job completion<br />Finished: UNSTABLE<br /><br />   Test_3<br />   #8  - SUCCESS<br />Started by upstream project &ldquo;Job_Set_2&rdquo; build number 8<br />Building in workspace C:\Users\oivasiv.jenkins\jobs\Test_3\workspace<br />Setting result to [Success]<br />Build step &lsquo;Set the build result&rsquo; changed build result to SUCCESS<br />Notifying upstream projects of job completion<br />Finished: SUCCESS<br /><br />Build step &lsquo;Groovy Postbuild&rsquo; changed build result to FAILURE<br />Build step &lsquo;Groovy Postbuild&rsquo; marked build as failure<br />Notifying upstream projects of job completion<br />Finished: FAILURE<br /><br /></pre></div>So, what are the benefits of such jobs status aggregation and Groovy post-processing:<br /><ul><li>we have jobs status in one place</li><li>e-mail notification sent from <b>Main_Job</b> contains this status</li><li>ability to implement any custom post-processing logic</li><li>ability to re-use the other plugins features via groovy scrip </li></ul></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jenkins Enhancements Without Plugins]]></title>
    <link href="http://halyph.com/blog/2012/12/31/jenkins-enhancements-without-plugins/"/>
    <updated>2012-12-31T01:50:00+02:00</updated>
    <id>http://halyph.com/blog/2012/12/31/jenkins-enhancements-without-plugins</id>
    <content type="html"><![CDATA[<div class="separator" style="clear: both; text-align: center;">
    <a href="http://3.bp.blogspot.com/-G0y3vRvF8Gk/UODT7t-pUCI/AAAAAAAABF4/JxoydHYGUvQ/s1600/logo.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="200" src="http://3.bp.blogspot.com/-G0y3vRvF8Gk/UODT7t-pUCI/AAAAAAAABF4/JxoydHYGUvQ/s200/logo.png" width="144" /></a>
</div>


<p><a href="http://jenkins-ci.org/">Jenkins</a> is a popular open source continuous integration server. I use it heavily. Jenkins is super extensible CI server with huge plugins repository.
<br />But I must admit that there are a lot of cases when all these Jenkins plugin&rsquo;s &ldquo;zoo&rdquo; doesn&rsquo;t help. What does it mean?:
<br /></p>

<ul>
    <li>we need a tons of plugin to solve some non-trivial problem,</li>
    <li>too many plugins dependencies which must be properly managed</li>
    <li>some available plugins partially provide required functionality</li>
    <li>some plugins provide required functionality but contain bugs</li>
    <li>or it might be impossible to find necessary plugin, and task have to be done ASAP</li>
</ul>


<p>Based on these cases mentioned above we have at least two solutions:
<br /></p>

<ol>
    <li>Implement own plugin which will provide all required functionality. It will take some time and slowdown the overall progress for this particular business task</li>
    <li>Use some Jenkins extra facilities which gives us a chance for Jenkins automation without plugin writing</li>
</ol>


<p>I&rsquo;m a real fun od 2d solution (at least as a prototyping phase or quick-and-dirty solution right-now-right-away).
<br />
<br />So, what&rsquo;s the magic? Jenkins has two nice plugins (of cause there are much more similar plugin, but these two are the best for quick start) which give us a possibility to write Groovy scripts for <i><b>build</b></i> and <i><b>post-build</b></i> phases:
<br /></p>

<ul>
    <li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Groovy+plugin">Groovy plugin</a> for Build phase</li>
    <li><a href="https://wiki.jenkins-ci.org/display/JENKINS/Groovy+Postbuild+Plugin">Groovy Postbuild Plugin</a> for Post-build phase</li>
</ul>


<p><strong>Pros</strong>:
<br /></p>

<ul>
    <li>Groovy scripts have access to whole Jenkins infrastructure (Jenkins packages) and can invoke functionality of third-party plugins installed in this Jenkins instance</li>
    <li>It&#8217;s very easy to prototype your ideas and validate automation approaches</li>
    <li>It gives us very quick business results</li>
    <li>Groovy scripts can automate really amazing and non-trivial tasks</li>
</ul>


<p><strong>Cons:</strong>
<br /></p>

<ul>
    <li>at the end these Groovy scripts are not easy for automated testing</li>
    <li>version managements for these scripts involve additional work (implement simple import/export tool for job configuration)</li>
    <li>these Groovy scripts can have dependency on some third-party plugins and these dependency must me somehow managed as well</li>
    <li>testing and debugging are really painful activities, because it involve too many interactions with Jenkins UI, etc. (yes, it can be somehow improved via extending both Groovy plugins, but it&#8217;s extra work)</li>
</ul>

]]></content>
  </entry>
  
</feed>
