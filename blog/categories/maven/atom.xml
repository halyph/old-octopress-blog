<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Maven | Knowledge Is Everything]]></title>
  <link href="http://halyph.com/blog/categories/maven/atom.xml" rel="self"/>
  <link href="http://halyph.com/"/>
  <updated>2015-03-21T21:31:02+02:00</updated>
  <id>http://halyph.com/</id>
  <author>
    <name><![CDATA[Orest Ivasiv]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to Download Jars From Maven Central]]></title>
    <link href="http://halyph.com/blog/2015/03/17/how-to-download-jars-from-maven-central/"/>
    <updated>2015-03-17T18:00:00+02:00</updated>
    <id>http://halyph.com/blog/2015/03/17/how-to-download-jars-from-maven-central</id>
    <content type="html"><![CDATA[<center>
<img src="/images/blog/java.png">
<img src="/images/blog/ivy.png">
<img src="/images/blog/maven.png">
</center>


<p>We know how to download Java libraries with it&rsquo;s dependencies (transitive included) via Maven <em>pom.xml</em>, Ant/Ivy <em>build.xml</em> script, Gradle <em>build.gradle</em> script etc.
But what if we need to download them without these scripts.</p>

<p>There are several ways to do this.
Assume that we&rsquo;d like to download <code>spark-core</code> library (<code>groupId=com.sparkjava, artifactId=spark-core, version=2.1</code>) with all dependencies from <a href="http://search.maven.org/#artifactdetails%7Ccom.sparkjava%7Cspark-core%7C2.1%7Cjar">Maven Central</a> into <code>lib</code> folder.</p>

<h2>Use Maven3 dependency plugin</h2>

<p>Here is there variants for lib download:
&#8220;` bash Download library with all dependencies</p>

<h1>Specify repoUrl (it&rsquo;s optional)</h1>

<p>mvn dependency:get -DrepoUrl=<a href="http://download.java.net/maven/2/">http://download.java.net/maven/2/</a> -DgroupId=com.sparkjava -DartifactId=spark-core -Dversion=2.1</p>

<h1>OR use default repoUrl</h1>

<p>mvn dependency:get -DgroupId=com.sparkjava -DartifactId=spark-core -Dversion=2.1</p>

<h1>OR use parameter artifact as groupId:artifactId:version</h1>

<p>mvn dependency:get -Dartifact=com.sparkjava:spark-core:2.1
&#8220;`</p>

<p>Now we need to copy just downloaded artifacts in our working directory:
&#8220;` bash Copy jars from local maven repo
mvn dependency:copy-dependencies -f $HOME/.m2/repository/com/sparkjava/spark-core/2.1/spark-core-2.1.pom -DoutputDirectory=$(pwd)/lib</p>

<h1>the previous command doesn&rsquo;t copy spark-core-x.x.jar, that&rsquo;s why we should copy it manually</h1>

<p>cp $HOME/.m2/repository/com/sparkjava/spark-core/2.1/spark-core-2.1.jar $(pwd)/lib
&#8220;`</p>

<h2>Use standalone Ivy</h2>

<p>We can use Ivy as standalone jar to download Maven dependencies without creating Ant build file:</p>

<pre><code class="bash"># 1. Download the latest ivy jar (currently it's v.2.4.0)
curl -L -O http://search.maven.org/remotecontent?filepath=org/apache/ivy/ivy/2.4.0/ivy-2.4.0.jar

# 2. Run ivy.jar to retrieve all dependencies
java -jar ivy-2.4.0.jar -dependency com.sparkjava spark-core 2.1 -retrieve "lib/[artifact]-[revision](-[classifier]).[ext]"
</code></pre>

<p>As you can see Ivy downloads approach is much simpler. The only cons (or pros, it depends) that <strong>ivy.jar</strong> should be additionally downloaded.</p>

<h2>Calling Ivy from Groovy or Java</h2>

<p>Here I&rsquo;ve decided to store <a href="http://makandracards.com/evgeny-goldin/5817-calling-ivy-from-groovy-or-java">Evgeny&rsquo;s Goldin</a> code snippet as a reference for myself. Programmatic artifacts downloads is not a common operation. It&rsquo;s alway nice to know the general concept how it can be done. Especially when Ivy documentation is not very informative.</p>

<pre><code class="java Groovy snippet of calling Ivy">import org.apache.ivy.Ivy
import org.apache.ivy.core.module.descriptor.DefaultDependencyDescriptor
import org.apache.ivy.core.module.descriptor.DefaultModuleDescriptor
import org.apache.ivy.core.module.id.ModuleRevisionId
import org.apache.ivy.core.resolve.ResolveOptions
import org.apache.ivy.core.settings.IvySettings
import org.apache.ivy.plugins.resolver.URLResolver
import org.apache.ivy.core.report.ResolveReport
import org.apache.ivy.plugins.parser.xml.XmlModuleDescriptorWriter


public File resolveArtifact(String groupId, String artifactId, String version) {
        //creates clear ivy settings
        IvySettings ivySettings = new IvySettings();
        //url resolver for configuration of maven repo
        URLResolver resolver = new URLResolver();
        resolver.setM2compatible(true);
        resolver.setName('central');
        //you can specify the url resolution pattern strategy
        resolver.addArtifactPattern(
            'http://repo1.maven.org/maven2/[organisation]/[module]/[revision]/[artifact](-[revision]).[ext]');
        //adding maven repo resolver
        ivySettings.addResolver(resolver);
        //set to the default resolver
        ivySettings.setDefaultResolver(resolver.getName());
        //creates an Ivy instance with settings
        Ivy ivy = Ivy.newInstance(ivySettings);

        File ivyfile = File.createTempFile('ivy', '.xml');
        ivyfile.deleteOnExit();

        String[] dep = [groupId, artifactId, version]

        DefaultModuleDescriptor md =
                DefaultModuleDescriptor.newDefaultInstance(ModuleRevisionId.newInstance(dep[0],
                dep[1] + '-caller', 'working'));

        DefaultDependencyDescriptor dd = new DefaultDependencyDescriptor(md,
                ModuleRevisionId.newInstance(dep[0], dep[1], dep[2]), false, false, true);
        md.addDependency(dd);

        //creates an ivy configuration file
        XmlModuleDescriptorWriter.write(md, ivyfile);

        String[] confs = ['default'];
        ResolveOptions resolveOptions = new ResolveOptions().setConfs(confs);

        //init resolve report
        ResolveReport report = ivy.resolve(ivyfile.toURL(), resolveOptions);

        //so you can get the jar library
        File jarArtifactFile = report.getAllArtifactsReports()[0].getLocalFile();

        return jarArtifactFile;
}

resolveArtifact( 'log4j', 'log4j', '1.2.16' )
</code></pre>

<h2>References</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/15450383/using-maven-to-download-dependencies-to-a-directory-on-the-command-line/15456621">Using Maven to download dependencies to a directory on the command line - Stack Overflow</a></li>
<li><a href="http://stackoverflow.com/questions/15598612/simplest-ivy-code-to-programmatically-retrieve-dependency-from-maven-central">Simplest Ivy code to programmatically retrieve dependency from Maven Central - Stack Overflow</a></li>
<li><a href="http://makandracards.com/evgeny-goldin/5817-calling-ivy-from-groovy-or-java">Calling Ivy from Groovy or Java</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven Flow for Simple App Creation]]></title>
    <link href="http://halyph.com/blog/2015/02/13/maven-flow-for-simple-app-creation/"/>
    <updated>2015-02-13T00:18:30+02:00</updated>
    <id>http://halyph.com/blog/2015/02/13/maven-flow-for-simple-app-creation</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/blog/java.png"></p>

<p>I provided my reflections about <em>&ldquo;Java for Everything&rdquo;</em> in the previous <a href="/blog/2015/02/13/do-we-need-java-for-everything">post</a>.
Here we will review other implementation of this concept.</p>

<p>I have the next concerns about any Java application (big or small):</p>

<ul>
<li>library dependency management must be simple</li>
<li>it&rsquo;s very bad practice to distribute sources along with libraries (dependency management tools must be used instead: Ivy, Maven, Gradle, etc.)</li>
<li>small application might have a little bit different project layout (not equals to traditional Maven layout)</li>
<li>we should be able to setup IDE (in my case <a href="https://www.jetbrains.com/idea/">Intellij IDEA</a>) as quick a possible. I hate editing Java programs in plain text editor</li>
<li>it must be a convenient way to run Java application with different arguments in <em>production</em> and <em>development</em> modes</li>
</ul>


<h2>Use Case</h2>

<p>We have to create simple and small REST application based on <a href="https://github.com/perwendel/spark">Spark Java framework</a> (A Sinatra inspired framework for Java).</p>

<p>Here is the source:
&#8220;` java
import static spark.Spark.get;
import static spark.SparkBase.port;</p>

<p>public class App {
    public static void main( String[] args ) throws NumberFormatException {</p>

<pre><code>    for(String arg: args) System.out.printf("&gt; %s", arg);

    get("/hello", (request, response) -&gt; {
        return "Hello World!";
    });
}
</code></pre>

<p>} <br/>
&#8220;`</p>

<p>So, here is the list of issues:</p>

<ul>
<li>get Spark dependency with all transitive dependencies</li>
<li>pass command-line arguments into the app</li>
<li>use this application in development mode and in &ldquo;production&rdquo; (packed in jar)</li>
</ul>


<h2>Traditional Maven Way</h2>

<ul>
<li><p>Generate empty project via Maven archetype
<code>bash
mvn archetype:generate \
-DgroupId=com.halyph \
-DartifactId=sparkblog \
-Dpackage=com.halyph.blog \
-Dversion=1.0-SNAPSHOT \
-DarchetypeGroupId=org.apache.maven.archetypes \
-DarchetypeArtifactId=maven-archetype-quickstart \
-DinteractiveMode=false
</code></p></li>
<li><p>Open this in IDEA (I don&rsquo;t use other IDEs) via &ldquo;Open File or Project&rdquo; and select folder with generated <strong>pom.xml</strong> file. We don&rsquo;t need tests, so we can delete <em>src->test</em> folder and remove junit dependency from <strong>pom.xml</strong> file. Now, we can easily run our application via IDE.</p></li>
<li><p>Add Spark framework dependency to <strong>pom.xml</strong> and update our <strong>App</strong> class
&#8220;` xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion></p>

<p><groupId>com.halyph</groupId>
<artifactId>sparkblog</artifactId>
<version>1.0-SNAPSHOT</version>
<packaging>jar</packaging></p>

<p><name>sparkblog</name>
<url><a href="http://maven.apache.org">http://maven.apache.org</a></url></p>

<p><properties>
  &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding>
</properties></p>

<p><dependencies>
  <dependency>
    <groupId>com.sparkjava</groupId>
    <artifactId>spark-core</artifactId>
    <version>2.1</version>
  </dependency>
</dependencies></p>

<p><build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-compiler-plugin</artifactId>
      <version>3.1</version>
      <configuration>
        <target>1.8</target>
        <source>1.8</source>
      </configuration>
    </plugin>
  </plugins>
</build>
</project>
&#8220;`</p></li>
</ul>


<pre><code class="java">package com.halyph.blog;

import static spark.Spark.get;

public class App {
    public static void main(String[] args) throws NumberFormatException {

        String myArgs = "";
        for (String arg : args) {
            System.out.printf("&gt; %s", arg);
            myArgs += arg + " : ";
        }
        System.out.println();
        final String finalMyArgs = myArgs;
        get("/hello", (request, response) -&gt; {
            return "Hello World!\n args = " + finalMyArgs;
        });
    }
}
</code></pre>

<p>This application can be easily run via IDE, but lets run it via Maven</p>

<ul>
<li>We should use <a href="http://mojo.codehaus.org/exec-maven-plugin/usage.html">Exec Maven Plugin</a> to run the app with all dependencies
&#8220;` bash
$ mvn clean compile exec:java -Dexec.mainClass=&ldquo;com.halyph.blog.App&rdquo;  -Dexec.args=&ldquo;9090 one 1 2&rdquo;
[INFO] Scanning for projects&hellip;
[INFO]
[INFO] &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
[INFO] Building sparkblog 1.0-SNAPSHOT
[INFO] &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
[INFO]
[INFO] &mdash; maven-clean-plugin:2.4.1:clean (default-clean) @ sparkblog &mdash;
[INFO] Deleting d:\MyProjects\jwrapper\bloggg\sparkblog\target
[INFO]
[INFO] &mdash; maven-resources-plugin:2.5:resources (default-resources) @ sparkblog &mdash;
[debug] execute contextualize
[INFO] Using &lsquo;UTF-8&rsquo; encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory d:\MyProjects\sparkblog\src\main\resources
[INFO]
[INFO] &mdash; maven-compiler-plugin:3.1:compile (default-compile) @ sparkblog &mdash;
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to d:\MyProjects\jwrapper\bloggg\sparkblog\target\classes
[INFO]
[INFO] >>> exec-maven-plugin:1.2.1:java (default-cli) @ sparkblog >>>
[INFO]
[INFO] &lt;&lt;&lt; exec-maven-plugin:1.2.1:java (default-cli) @ sparkblog &lt;&lt;&lt;
[INFO]
[INFO] &mdash; exec-maven-plugin:1.2.1:java (default-cli) @ sparkblog &mdash;

<blockquote><p>9090> one> 1> 2
[Thread-1] INFO spark.webserver.SparkServer - == Spark has ignited &hellip;
[Thread-1] INFO spark.webserver.SparkServer - >> Listening on 0.0.0.0:4567
[Thread-1] INFO org.eclipse.jetty.server.Server - jetty-9.0.2.v20130417
[Thread-1] INFO org.eclipse.jetty.server.ServerConnector - Started ServerConnector@4afe75c9{HTTP/1.1}{0.0.0.0:4567}
&#8220;`</p></blockquote></li>
</ul>


<p>In case the application run configurations is persistent (&ldquo;main&rdquo; class and CLI arguments are changing rarely) we can configure it in <strong>pom.xml</strong>:
<code>xml
 &lt;build&gt;
    &lt;plugins&gt;
      ...
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;java&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
        &lt;configuration&gt;
          &lt;mainClass&gt;com.halyph.blog.App&lt;/mainClass&gt;
          &lt;arguments&gt;
            &lt;argument&gt;9090&lt;/argument&gt;
            &lt;argument&gt;one&lt;/argument&gt;
            &lt;argument&gt;1&lt;/argument&gt;
            &lt;argument&gt;2&lt;/argument&gt;
          &lt;/arguments&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
</code></p>

<ul>
<li>It&rsquo;s nice idea to use <code>mvn exec:java</code>, but it might be a little bit slow. So, we might decide to use some shell script which increase compiled application ramp up time. The problem is that the application have dependencies (which have transitive dependencies). I.e. <code>java</code> classpath have to be configured somehow.</li>
</ul>


<p>Well, I borrowed the ideas from &ldquo;<a href="http://saltnlight5.blogspot.com/2012/08/a-better-java-shell-script-wrapper.html">A better java shell script wrapper</a>&rdquo; script. Here it is:
&#8220;` bash</p>

<h1>!/usr/bin/env bash</h1>

<p>#</p>

<h1>Copyright 2012 Zemian Deng</h1>

<p>#</p>

<h1>A wrapper script that run any Java application in unix/cygwin bash env.</h1>

<p>#</p>

<h1>This script is assumed to be located in an application&rsquo;s &ldquo;bin&rdquo; directory. It will</h1>

<h1>auto resolve its directory location relative to the application path (which is one</h1>

<h1>parent up from the script.) Therefore, this script can be run any where in the file</h1>

<h1>system and it will still reference the same application directory.</h1>

<p>#</p>

<h1>This script will by default auto setup a Java classpath that picks up any &ldquo;config&rdquo;</h1>

<h1>and &ldquo;lib&rdquo; directories under the application directory. It also will also add a</h1>

<h1>any typical Maven project output directories such as &ldquo;target/test-classes&rdquo;,</h1>

<h1>&ldquo;target/classes&rdquo;, and &ldquo;target/dependency&rdquo; into classpath. This can be disable by</h1>

<h1>setting RUN_JAVA_NO_AUTOCP=1.</h1>

<p>#</p>

<h1>If the &ldquo;Default parameters&rdquo; section bellow doesn&rsquo;t match to user&rsquo;s env, then user</h1>

<h1>may override these variables in their terminal session or preset them in shell&rsquo;s</h1>

<h1>profile startup script. The values of all path should be in cygwin/unix path,</h1>

<h1>and this script will auto convert them into Windows path where is needed.</h1>

<p>#</p>

<h1>User may customize the Java classpath by setting RUN_JAVA_CP, which will prefix to existing</h1>

<h1>classpath, or use the &ldquo;-cp&rdquo; option, which will postfix to existing classpath.</h1>

<p>#</p>

<h1>Usage:</h1>

<h1>run-java [java_opts] <java_main_class> [-cp /more/classpath] [-Dsysprop=value]</h1>

<p>#</p>

<h1>Example:</h1>

<h1>run-java example.Hello</h1>

<h1>run-java example.Hello -Dname=World</h1>

<h1>run-java org.junit.runner.JUnitCore example.HelloTest -cp &ldquo;$HOME/apps/junit/lib/*&rdquo;</h1>

<p>#</p>

<h1>Created by: Zemian Deng 03/09/2012</h1>

<h1>This run script dir (resolve to absolute path)</h1>

<p>SCRIPT_DIR=$(cd $(dirname $0) &amp;&amp; pwd)    # This dir is where this script live.
APP_DIR=$(cd $SCRIPT_DIR/.. &amp;&amp; pwd)      # Assume the application dir is one level up from script dir.</p>

<h1>Default parameters</h1>

<p>JAVA_HOME=${JAVA_HOME:=$HOME/apps/jdk}     # This is the home directory of Java development kit.
RUN_JAVA_CP=${RUN_JAVA_CP:=$CLASSPATH}     # A classpath prefix before -classpath option, default to $CLASSPATH
RUN_JAVA_OPTS=${RUN_JAVA_OPTS:=}           # Java options (-Xmx512m -XX:MaxPermSize=128m etc)
RUN_JAVA_DEBUG=${RUN_JAVA_DEBUG:=}         # If not empty, print the full java command line before executing it.
RUN_JAVA_NO_PARSE=${RUN_JAVA_NO_PARSE:=}   # If not empty, skip the auto parsing of -D and -cp options from script arguments.
RUN_JAVA_NO_AUTOCP=${RUN_JAVA_NO_AUTOCP:=} # If not empty, do not auto setup Java classpath
RUN_JAVA_DRY=${RUN_JAVA_DRY:=}             # If not empty, do not exec Java command, but just print</p>

<h1>OS specific support.  $var <em>must</em> be set to either true or false.</h1>

<p>CYGWIN=false;
case &ldquo;<code>uname</code>&rdquo; in
  CYGWIN*) CYGWIN=true ;;
esac</p>

<h1>Define where is the java executable is</h1>

<p>JAVA_CMD=java
if [ -d &ldquo;$JAVA_HOME&rdquo; ]; then
    JAVA_CMD=&ldquo;$JAVA_HOME/bin/java&rdquo;
fi</p>

<h1>Auto setup applciation&rsquo;s Java Classpath (only if they exists)</h1>

<p>if [ -z &ldquo;$RUN_JAVA_NO_AUTOCP&rdquo; ]; then
    if [ -d &ldquo;$APP_DIR/config&rdquo; ]; then RUN_JAVA_CP=&ldquo;$RUN_JAVA_CP:$APP_DIR/config&rdquo; ; fi
    if [ -d &ldquo;$APP_DIR/target/test-classes&rdquo; ]; then RUN_JAVA_CP=&ldquo;$RUN_JAVA_CP:$APP_DIR/target/test-classes&rdquo; ; fi
    if [ -d &ldquo;$APP_DIR/target/classes&rdquo; ]; then RUN_JAVA_CP=&ldquo;$RUN_JAVA_CP:$APP_DIR/target/classes&rdquo; ; fi
    if [ -d &ldquo;$APP_DIR/target/dependency&rdquo; ]; then RUN_JAVA_CP=&ldquo;$RUN_JAVA_CP:$APP_DIR/target/dependency/<em>&rdquo; ; fi
    if [ -d &ldquo;$APP_DIR/lib&rdquo; ]; then RUN_JAVA_CP=&ldquo;$RUN_JAVA_CP:$APP_DIR/lib/</em>&rdquo; ; fi
fi</p>

<p>ARGS=&ldquo;$@&rdquo;</p>

<h1>Parse addition &ldquo;-cp&rdquo; and &ldquo;-D&rdquo; after the Java main class from script arguments</h1>

<h1>This is done for convenient sake so users do not have to export RUN_JAVA_CP and RUN_JAVA_OPTS</h1>

<h1>saparately, but now they can pass into end of this run-java script instead.</h1>

<h1>This can be disable by setting RUN_JAVA_NO_PARSE=1.</h1>

<p>if [ -z &ldquo;$RUN_JAVA_NO_PARSE&rdquo; ]; then
    # Prepare variables for parsing
    FOUND_CP=
    NEW_ARGS[0]=&lsquo;&rsquo;
    IDX=0</p>

<pre><code># Parse all arguments and look for "-cp" and "-D"
for ARG in "$@"; do
    if [[ -n $FOUND_CP ]]; then
        RUN_JAVA_CP="$RUN_JAVA_CP:$ARG"
        FOUND_CP=
    else
        case $ARG in
        '-cp')
            FOUND_CP=1
            ;;
        '-D'*)
            RUN_JAVA_OPTS="$RUN_JAVA_OPTS $ARG"
            ;;
        *)
            NEW_ARGS[$IDX]="$ARG"
            let IDX=$IDX+1
            ;;
        esac
    fi
done
ARGS="${NEW_ARGS[@]}"
</code></pre>

<p>fi</p>

<h1>Convert Windows Java Classpath</h1>

<p>if $CYGWIN; then
    RUN_JAVA_CP=$(cygpath -mp $RUN_JAVA_CP)
fi</p>

<h1>Display full Java command.</h1>

<p>if [ -n &ldquo;$RUN_JAVA_DEBUG&rdquo; ] || [ -n &ldquo;$RUN_JAVA_DRY&rdquo; ]; then
    echo &ldquo;$JAVA_CMD&rdquo; $RUN_JAVA_OPTS -cp &ldquo;$RUN_JAVA_CP&rdquo; $ARGS
fi</p>

<h1>Run Java Main class</h1>

<p>if [ -z &ldquo;$RUN_JAVA_DRY&rdquo; ]; then
    &ldquo;$JAVA_CMD&rdquo; $RUN_JAVA_OPTS -cp &ldquo;$RUN_JAVA_CP&rdquo; $ARGS
fi
&#8220;`</p>

<p>The main idea is to run <code>mvn dependency:copy-dependencies</code>, this will generate all the jar files into <code>target/dependency</code> folder</p>

<pre><code class="bash">$ mvn dependency:copy-dependencies
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building sparkblog 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:2.1:copy-dependencies (default-cli) @ sparkblog ---
[INFO] Copying spark-core-2.1.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\spark-core-2.1.jar
[INFO] Copying jetty-http-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-http-9.0.2.v20130417.jar
[INFO] Copying jetty-io-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-io-9.0.2.v20130417.jar
[INFO] Copying jetty-security-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-security-9.0.2.v20130417.jar
[INFO] Copying jetty-server-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-server-9.0.2.v20130417.jar
[INFO] Copying jetty-servlet-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-servlet-9.0.2.v20130417.jar
[INFO] Copying jetty-util-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-util-9.0.2.v20130417.jar
[INFO] Copying jetty-webapp-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-webapp-9.0.2.v20130417.jar
[INFO] Copying jetty-xml-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-xml-9.0.2.v20130417.jar
[INFO] Copying javax.servlet-3.0.0.v201112011016.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\javax.servlet-3.0.0.v201112011016.jar
[INFO] Copying slf4j-api-1.7.7.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\slf4j-api-1.7.7.jar
[INFO] Copying slf4j-simple-1.7.7.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\slf4j-simple-1.7.7.jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2.978s
[INFO] Finished at: Thu Feb 12 18:22:54 EET 2015
[INFO] Final Memory: 9M/243M
[INFO] ------------------------------------------------------------------------
</code></pre>

<p>Now, we can reuse the provided <em>above</em> script <strong>or</strong> use the provided <em>below</em> one-liner:
<code>bash
java -cp target\classes;target\dependency\* com.halyph.blog.App 9090 one 1 2
</code>
This one-liner is very simple and can be transformed to shell/batch scripts depending on the level of re-use you&rsquo;d like to implement.</p>

<ul>
<li>Now, it&rsquo;s time to created pre-packed application bundle which can be easily distributed. We will use <a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/usage-program.html">Maven Application Assembler Plugin</a>:
<code>xml
&lt;build&gt;
  &lt;plugins&gt;
   ...
    &lt;plugin&gt;
      &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
      &lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.9&lt;/version&gt;
      &lt;!--
      This (executions) section can be omitted.
      In case it's omitted we should call the next command to generate wrapper:
      mvn package appassembler:assemble
      --&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;phase&gt;package&lt;/phase&gt;
          &lt;goals&gt;
            &lt;goal&gt;assemble&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
      &lt;configuration&gt;
        &lt;programs&gt;
          &lt;program&gt;
            &lt;mainClass&gt;com.halyph.blog.App&lt;/mainClass&gt;
            &lt;id&gt;app&lt;/id&gt;
          &lt;/program&gt;
        &lt;/programs&gt;
      &lt;/configuration&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</code>

<blockquote><p>The Application Assembler Plugin is a Maven plugin for generating scripts for starting java applications. All dependencies and the artifact of the project itself are placed in a generated Maven repository in a defined assemble directory. All artifacts (dependencies + the artifact from the project) are added to the classpath in the generated bin scripts.</p></blockquote></li>
</ul>


<p><a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/usage-program.html">Maven Application Assembler Plugin</a> usage:
<code>bash  
$ mvn package
$ target/appassembler/bin/app
</code></p>

<blockquote><ul>
<li><p>All dependencies and the artifact itself are placed in the defined assemble directory (defaults to <code>$project.build.directory/appassembler</code>).</p></li>
<li><p>A <code>bin/</code> directory is created in the assemble directory and the generated bin scripts are placed in that directory (defaults to both unix shell scripts and Windows bat files).</p></li>
</ul>
</blockquote>

<p>Note: <a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/usage-program.html">Maven Application Assembler Plugin</a> have a lot of customization options, just check the documentation.</p>

<h2>Summary</h2>

<p>Here was shown that using such tool as Maven you can be productive and &ldquo;agile&rdquo; (use <a href="http://gradle.org">Gradle</a> if you&rsquo;d like to be in trend):</p>

<ul>
<li>generate project skeleton from scratch</li>
<li>open it in IDE without ceremony</li>
<li>call the app via Maven plugin</li>
<li>call it as plain CLI application, but with small ceremony (need to run <em>dependency:copy-dependencies</em>)</li>
<li>package the app for further distribution</li>
</ul>


<p>Yes, it&rsquo;s not a simple <em>write-one</em> Java &ldquo;script&rdquo;, but it&rsquo;s flexible enough to feel like it is.</p>

<h2>References</h2>

<ul>
<li><a href="/blog/2015/02/13/do-we-need-java-for-everything">Do We Need Java for Everything?</a></li>
<li><a href="http://saltnlight5.blogspot.com/2012/08/a-better-java-shell-script-wrapper.html">A better java shell script wrapper</a></li>
<li><a href="http://mojo.codehaus.org/exec-maven-plugin/usage.html">Exec Maven Plugin</a></li>
<li><a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/usage-program.html">Maven Application Assembler Plugin</a></li>
<li><a href="http://blog.plesslweb.ch/post/6628462331/wrapper-script-for-java-command-line-applications">Wrapper Script for Java Command-Line Applications</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
