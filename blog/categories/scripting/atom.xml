<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Scripting | Knowledge Is Everything]]></title>
  <link href="http://halyph.com/blog/categories/scripting/atom.xml" rel="self"/>
  <link href="http://halyph.com/"/>
  <updated>2015-09-28T03:13:38+03:00</updated>
  <id>http://halyph.com/</id>
  <author>
    <name><![CDATA[Orest Ivasiv]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Scripting in Scala]]></title>
    <link href="http://halyph.com/blog/2015/02/02/scripting-in-scala/"/>
    <updated>2015-02-02T00:18:00+02:00</updated>
    <id>http://halyph.com/blog/2015/02/02/scripting-in-scala</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/blog/scala.png"></p>

<p>Scala language compiles sources code to Java bytecode.  But, it has some nice scripting facilities. Let&rsquo;s review them.</p>

<p>So, the <code>scala</code> command is also a shell-script wrapper around the java command.</p>

<p>According to official <a href="http://www.scala-lang.org/files/archive/nightly/docs-2.10.1/manual/html/scala.html">scala utility</a> documentation (here highlighted only post-related notes):</p>

<blockquote><p><code>scala [ &lt;option&gt; ]... [ &lt;torun&gt; &lt;argument&gt;... ]</code></p>

<p>The <code>scala</code> utility runs Scala code using a Java runtime environment.</p>

<p>If a <strong>script</strong> file is specified to run, then the file is read and all Scala statements and declarations in the file are processed in order. Any arguments specified will be available via the argsvariable.</p>

<p>Script files may have an <strong>optional header</strong> that is ignored if present. There are two ways to format the header: either beginning with #! and ending with !#, or beginning with ::#! and ending with ::!#.</p>

<p>Such a header must have each header boundary start at the beginning of a line. Headers can be used to make stand-alone script files, as shown in the examples below.</p>

<p>Here is a complete Scala script (<strong>check.sh</strong>) for Unix:</p>

<pre><code>#!/bin/sh
exec scala "$0" "$@"
!#
Console.println("Hello, world!")
argv.toList foreach Console.println
</code></pre>

<p>Here is a complete Scala script (<strong>check.bat</strong>) for MS Windows:</p>

<pre><code>::#!
@echo off
call scala %0 %*
goto :eof
::!#
Console.println("Hello, world!")
argv.toList foreach Console.println
</code></pre>

<p>If you want to use the compilation cache to speed up multiple executions of the script (<strong>check.sh</strong>), then add <strong>-savecompiled</strong> to the scala command:</p>

<pre><code>#!/bin/sh
exec scala -savecompiled "$0" "$@"
!#
Console.println("Hello, world!")
argv.toList foreach Console.println
</code></pre></blockquote>

<p>These tricks give us an ability to run Scala script as plain shell script. Also, based on the setting above this script can have input parameters and <em>almost</em> cross-platform (see script header differences for Linux <strong>.vs.</strong> Windows).</p>

<p>Now, we should save the mentioned above code snippet in some file (e.g. <strong>check.sh</strong>) and make it executable. This script can be run as any Linux shell script <code>./check.sh</code> (<code>check.bat</code> - Windows).</p>

<a name="Scala.utility.internals"></a>
<h2>Scala utility internals</h2>

<a name="Linux"></a>
<h3>Linux</h3>

<p>Linux script header uses the next items:</p>

<ul>
<li><code>#!</code> it&rsquo;s <a href="http://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a> interpreter directive</li>
<li><code>exec</code> is used to run <code>scala</code> without creation new process. Commands which go right after <code>exec</code> will not be executed</li>
<li><code>!#</code> is simple marker for <code>scala</code> utility (see notes below)</li>
</ul>


<p>E.g.
This script
&#8220;`</p>

<a name="L...bin.sh"></a>
<h1>! /bin/sh</h1>

<p>echo Header
exec echo
!#
echo Body
<code>
will have the next output
</code>
$ ./test.sh
Header
&#8220;`</p>

<p>We will get error in case <code>exec</code> is removed:
&#8220;`</p>

<a name="L...bin.sh"></a>
<h1>! /bin/sh</h1>

<p>echo Header
!#
echo Body
<code>
Output
</code>
$ ./test.sh
Header
./test.sh: line 4: !#: command not found
Body</p>

<pre><code>### Windows
Windows batch script header uses the next items:

- `::` is a remark without displaying or executing that line when the batch file is run (see [Information on batch files]).
- `::#!`  is simple marker for `scala` utility (see notes below)
- `@echo off` disable echo
- `call` calls one batch program from another.
- `goto :eof` go to end of file
- `::!#` is simple marker for `scala` utility (see notes below)

The OS-specific script settings were identified, now let's dive deeper to understand how `scala` utility works.

### `scala` internals
This utility performs the next flow to run script:

1. Run `scala.tools.nsc.MainGenericRunner#process` and identify run target "as Script" (there are other targets) `ScriptRunner.runScriptAndCatch(settings, thingToRun, command.arguments)` 
2. `ScriptRunner` creates temp file `File.makeTemp("scalacmd", ".scala")`
3. Run compiler and clean script header
</code></pre>

<p>class ScriptRunner extends HasCompileSocket {
&hellip;
  private def withCompiledScript(
      settings: GenericRunnerSettings,
      scriptFile: String)
      (handler: String => Boolean): Boolean =
    {
      def mainClass = scriptMain(settings)</p>

<pre><code>     val compiler = newGlobal(settings, reporter)
     new compiler.Run compile List(scriptFile)
</code></pre>

<pre><code></code></pre>

<p>class Global
    /<em>* If this compilation is scripted, convert the source to a script source. </em>/
    private def scripted(s: SourceFile) = s match {
      case b: BatchSourceFile if settings.script.isSetByUser => ScriptSourceFile(b)
      case _ => s
    }</p>

<pre><code>/** Compile abstract file until `globalPhase`, but at least
 *  to phase "namer".
 */
def compileLate(file: AbstractFile) {
  if (!compiledFiles(file.path))
    compileLate(new CompilationUnit(scripted(getSourceFile(file))))
}
</code></pre>

<pre><code>
4. Cleanup shell script (remove header) via `SourceFile`. Now, it's clear why script's header have such *strange* closing markers (see line 21, `content drop headerLen` - actual header remove)
</code></pre>

<p>object ScriptSourceFile {
  /<em><em> Length of the script header from the given content, if there is one.
   *  The header begins with &ldquo;#!&rdquo; or &ldquo;::#!&rdquo; and ends with a line starting
   *  with &ldquo;!#&rdquo; or &ldquo;::!#&rdquo;.
   </em>/
  def headerLength(cs: Array[Char]): Int = {
    val headerPattern = Pattern.compile(&ldquo;&rdquo;&ldquo;((?m)<sup>::</sup>?!#.</em>|^.<em>/env .</em>)(\r|\n|\r\n)&rdquo;&ldquo;&rdquo;)
    val headerStarts  = List(&ldquo;#!&rdquo;, &ldquo;::#!&rdquo;)</p>

<pre><code>if (headerStarts exists (cs startsWith _)) {
  val matcher = headerPattern matcher cs.mkString
  if (matcher.find) matcher.end
  else throw new IOException("script file does not close its header with !# or ::!#")
}
else 0
</code></pre>

<p>  }</p>

<p>  def apply(file: AbstractFile, content: Array[Char]) = {
    val underlying = new BatchSourceFile(file, content)
    val headerLen = headerLength(content)
    val stripped = new ScriptSourceFile(underlying, content drop headerLen, headerLen)</p>

<pre><code>stripped
</code></pre>

<p>  }
&#8220;`</p>

<a name="Add.libraries.to.Scala.script"></a>
<h2>Add libraries to Scala script</h2>

<p>Scala script libraries (<strong>jar</strong>s) can be added in script&rsquo;s header section:
&#8220;`</p>

<a name="L..bin.sh"></a>
<h1>!/bin/sh</h1>

<p>exec scala -classpath &ldquo;lib/lib.1.jar:lib/lib.2.jar&rdquo; &ldquo;$0&rdquo; &ldquo;$@&rdquo;
!#
&#8220;`</p>

<a name="Summary"></a>
<h2>Summary</h2>

<p>There is nothing magical in Scala interpretation. Every single peace of code must be compiled. Such interesting <em>scripting</em> approach can be applied to Java as well.</p>

<p>Unfortunately, Scala is not looks like nice scripting language (because it&rsquo;s <strong>not</strong> designed for this use case). It will be uncomfortable &ldquo;scripting&rdquo; in Scala without IDE.</p>

<a name="References"></a>
<h2>References</h2>

<ul>
<li><a href="http://timperrett.com/2011/08/01/system-scripting-with-scala/">System Scripting with Scala</a></li>
<li><a href="http://www.scala-lang.org/files/archive/nightly/docs-2.10.1/manual/html/scala.html">scala utility</a></li>
<li><a href="http://en.wikipedia.org/wiki/Shebang_(Unix)">shebang</a></li>
<li><a href="http://www.computerhope.com/batch.htm">Information on batch files</a></li>
<li>Scala Sources:

<ul>
<li><a href="https://github.com/scala/scala/blob/v2.11.5/src/compiler/scala/tools/nsc/ScriptRunner.scala#">ScriptRunner.scala</a></li>
<li><a href="https://github.com/scala/scala/blob/v2.11.5/src/reflect/scala/reflect/internal/util/SourceFile.scala">SourceFile.scala</a></li>
<li><a href="https://github.com/scala/scala/blob/v2.11.5/src/compiler/scala/tools/nsc/Global.scala">Global.scala</a></li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why I've Chosen Ruby as Main Scripting Language for My Toolbox]]></title>
    <link href="http://halyph.com/2009/12/why-i-chosen-ruby-as-main-scripting.html"/>
    <updated>2009-12-27T12:42:00+02:00</updated>
    <id>http://halyph.com/2009/12/why-i-chosen-ruby-as-main-scripting</id>
    <content type="html"><![CDATA[<p>There are a lot of scripting languages: Perl, Python, Lua, Tcl, Ruby, JavaScript, Scala, Groovy, Erlang, Lisp, Scheme and Bash/Awk(as shell scripting).</p>

<p>There are criteria I&rsquo;ve tried to match for my scripting language of choice:</p>

<ul>
<li>Easy to learn</li>
<li>Active and big community<em>   Amount of books and tutorials which are available</em>   How many screencasts, conference videos are on-line?</li>
<li>Can replace shell scripting?</li>
<li>Number of text editors which support selected language</li>
<li>Code for fun? Is it suitable for selected language</li>
<li>Amount of useful frameworks and libraries</li>
</ul>


<p>Let&rsquo;s discuss each of them.</p>

<ul>
<li><p><strong>JavaScript.</strong> I like this language, but it doesn&rsquo;t have standard serve-side API. There are a lot of implementation, but community  have to work a lot to get valuable result. Check <a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS</a> to get more info</p></li>
<li><p><strong>Perl</strong>. I&rsquo;ve never tried to dig deeply into this and code style doesn&rsquo;t suitable for me. I can&rsquo;t code for fun.  Number of tutorials/books are huge. Community is big. But, it&rsquo;s not my language of choice.</p></li>
<li><p><strong>Lua</strong>. There are no killer features, as for me. In general language are cool and fast. Easy to learn.</p></li>
<li><p><strong>Tcl</strong>.  I just don&rsquo;t like Tcl language. It&rsquo;s main stopper for me. Community not so big in comparison with other languages. Amount the books is limited.</p></li>
<li><p><strong>Lisp/Scheme</strong>. Great languages, but not for shell oriented scripting (It will be awkward to write shell scripts)</p></li>
<li><p><strong>Erlang</strong>. Interesting language, but it&rsquo;s not general purpose. Good for concurrency domain. I have to skip it.</p></li>
<li><p><strong>Scala/Groovy</strong>. Yet another scripting languages. I can see hype near these languages, especially Scala in Java community.  I can predict, that the next year will have got another hype language(s).</p></li>
<li><p><strong>Bash/Awk</strong>. I&rsquo;d like to learn these two, but I&rsquo;m windows user and I don&rsquo;t have a possibility to use these during my work. I can use Cygwin/MSYS, but it will be strange, awkward. It will be unnatural. I&rsquo;m sure I need to get additional experience in Bash scripting, but not now. Time is my enemy.</p></li>
</ul>


<p><strong>Python vs Ruby.</strong> These two are very similar. Both have big and active community. Both are general purpose languages. Both are great.
But I falling in love with Ruby blocks. I love <a href="http://railscasts.com/.">http://railscasts.com/.</a>  I&rsquo;m not web-developer, but Rails concept is super-productive.  I just love Ruby community.</p>

<p>But, there is one drawback. There is a ton of libraries and frameworks which are doing the same thing. Community super productive  and  it&rsquo;s in developing. There is no consistency. So, I have to be aware of any big changes in my favorite libraries/frameworks. I know it sounds strange but it&rsquo;s IMHO.</p>

<p>Shell scripting and task automation is one of the main direction to be productive. From time to time I have to work on different OS&rsquo;s (Windows, Linux, OS X) and environment. But my primary work station is Windows based. I&rsquo;d like to have consistent scripting and automation tools for all these OS/environments. We can automate everything with Bash, etc. But what about Windows? So, choosing scripting language was good decision to create multi-platform toolbox. So, I can use my knowledge on any machine with minimal rework (if required).</p>

<p>Any developer should have some scripting language in his arsenal. <strong>The right tool for the job</strong>. Keep follow this idea and you will be productive.</p>
]]></content>
  </entry>
  
</feed>
