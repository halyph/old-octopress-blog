<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | Knowledge Is Everything]]></title>
  <link href="http://halyph.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://halyph.com/"/>
  <updated>2015-07-14T00:58:51+03:00</updated>
  <id>http://halyph.com/</id>
  <author>
    <name><![CDATA[Orest Ivasiv]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java Full Stack Web Framework]]></title>
    <link href="http://halyph.com/blog/2015/04/06/java-full-stack-web-framework/"/>
    <updated>2015-04-06T23:43:10+03:00</updated>
    <id>http://halyph.com/blog/2015/04/06/java-full-stack-web-framework</id>
    <content type="html"><![CDATA[<p><img class="right" src="/images/blog/java.png"></p>

<p><ul>
 <li>
 <ul>
  <li><a href="#Overview">Overview</a></li>
  <li><a href="#Grails">Grails</a></li>
  <li><a href="#Play.Framework.2">Play Framework 2</a></li>
  <li><a href="#Code.Generation.Frameworks">Code Generation Frameworks</a>
  <ul>
   <li><a href="#Spring.Roo">Spring Roo</a></li>
   <li><a href="#JBoss.Forge">JBoss Forge</a></li>
   <li><a href="#AppFuse">AppFuse</a></li>
   <li><a href="#JHipster">JHipster</a></li>
  </ul>
  </li>
  <li><a href="#Domain-driven.Frameworks">Domain-driven Frameworks</a></li>
  <li><a href="#Others">Others</a></li>
  <li><a href="#Summary">Summary</a></li>
  <li><a href="#References">References</a></li>
 </ul>
 </li>
</ul>

</p>

<p>I believe that everybody knows the most popular full-stack web framework - <a href="http://rubyonrails.org">Ruby on Rails</a>. Of course there are other frameworks for Ruby language, but Rails is the number one. Now, the question: how many full-stack web frameworks exist for Java?</p>

<a name="Overview"></a>
<h2>Overview</h2>

<p>Let&rsquo;s define the desired items for full-stack web framework:</p>

<ul>
<li>CoC - <a href="http://en.wikipedia.org/wiki/Convention_over_configuration">Convention over configuration</a></li>
<li>MVC - <a href="http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Model-view-controller</a></li>
<li>DRY - <a href="http://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don&rsquo;t repeat yourself</a></li>
<li>Scaffolding (<em>it was one of the major selling point on the early stage of Rails</em>)

<ul>
<li>Easy prototyping</li>
</ul>
</li>
<li>Data/Persistent Layer / ORM</li>
<li>DB schema migration</li>
<li>URI Routing</li>
<li>HTML Rendering / Template engines</li>
<li>Testing</li>
<li>REST API</li>
<li>Security</li>
<li>Caching</li>
<li>Request Filtering</li>
<li>Session Management</li>
<li>Form Validation</li>
<li>i18n/l10n</li>
</ul>


<a name="Grails"></a>
<h2>Grails</h2>

<p>I think  <a href="https://grails.org">Grails</a> was and is the single &ldquo;true&rdquo; Rails reincarnation on JVM. Grails is based on <a href="http://www.groovy-lang.org/">Groovy</a> language. It support all concepts Rails supports. It&rsquo;s based on Spring/Hibernate and Gradle since v.3.0 (Grails v.3.0.0 was released on <strong>Mar 31, 2015</strong>).</p>

<p>Grails v.3 is build on <a href="http://projects.spring.io/spring-boot/">Spring Boot</a>.</p>

<p>Some people arguing that Grails v.3 acts as simple wrapper on top of Spring Boot and now it does not worth any investments. But, we must not agree as CoC and DRY principles are very vague.</p>

<a name="Play.Framework.2"></a>
<h2>Play Framework 2</h2>

<p><a href="https://www.playframework.com/">Play Framework 2</a> is a special player. It has two implementations: Java and Scala. Actually Java version is not as powerful as Scala due to Java, as a language, &ldquo;limitation&rdquo;. This framework lives under <a href="http://typesafe.com/">Typesafe</a> umbrella, aka <strong>&ldquo;Typesafe Reactive Platform&rdquo;</strong>.</p>

<p>Play is just different. It&rsquo;s not Servlet-based and is built on <a href="http://netty.io/">Netty</a> async framework. A lot of people claiming that Play is very cool and productive. I haven&rsquo;t tried it yet. But it looks promising and interesting.</p>

<a name="Code.Generation.Frameworks"></a>
<h2>Code Generation Frameworks</h2>

<p>I decided to define the special category &ldquo;Code Generation&rdquo;. Frameworks which are related  to this category are not full stack, but can be called as RAD (Rapid Application Development) frameworks.</p>

<a name="Spring.Roo"></a>
<h3>Spring Roo</h3>

<p><a href="http://projects.spring.io/spring-roo/">Spring Roo</a> was very popular some time ago and had a lot of investments from VMWare (former Spring stack owner). Later, the ownership was transferred to <a href="http://www.disid.com">DISIG</a>.</p>

<p>Spring Roo is code generation framework, built on top of Spring stack. It&rsquo;s useful for quick prototyping.</p>

<a name="JBoss.Forge"></a>
<h3>JBoss Forge</h3>

<p><a href="http://forge.jboss.org/">JBoss Forge</a> is conceptually equal to Spring Roo, but linked to Java EE stack (like <a href="http://wildfly.org/">Wildfly</a>, <a href="http://tomee.apache.org/apache-tomee.html">TomEE</a>) and Maven. It&rsquo;s relly cool if you work with Java EE a lot. Forge is shine in prototyping and code generation. Community looks vibrant and active.</p>

<a name="AppFuse"></a>
<h3>AppFuse</h3>

<p><a href="http://appfuse.org/">AppFuse</a> can be called as ramp-up framework. The main goal is to quickly generate project with pre-onfigured functionality (see <code>mvn archetype:generate</code>).</p>

<a name="JHipster"></a>
<h3>JHipster</h3>

<p><a href="https://jhipster.github.io/">JHipster</a> is brand new and based on Spring Boot and Angular.js v.1.x. Classical code generation like in Forge or Spring Roo. But, code generation is build on top of node.js tool <a href="http://yeoman.io/">Yeoman</a>. Concept is very interesting, especially when it uses so hipster&rsquo;s technologies ;-).
It can generate both back-end (REST endpoint) and front-end (Angular.js Single-page application), even <a href="http://www.liquibase.org/">Liquibase</a> migrations (which is cool too).</p>

<a name="Domain-driven.Frameworks"></a>
<h2>Domain-driven Frameworks</h2>

<p>There is a very special category Domain-driven frameworks. For this category I&rsquo;ve selected two most popular frameworks: <a href="http://www.openxava.org/">OpenXava</a> and <a href="http://isis.apache.org/">Apache Isis</a>. The main idea is that they can generate views and RESTs based on domain entities. Both frameworks have active community. They have &ldquo;own&rdquo; concepts and no hipsters technologies. The usage domain is very narrow, I guess they can be easily used to quickly general application&rsquo;s back-offices (aka admin pages) and prototyping.</p>

<a name="Others"></a>
<h2>Others</h2>

<p>There are several others frameworks <a href="http://www.ninjaframework.org/">Ninja</a>, <a href="http://javalite.io/">Javalight</a>, <a href="http://joddframework.org/">Jodd</a>, <a href="http://jooby.org/">Jobby</a> and <a href="https://github.com/airlift/airlift">airlift</a>. They are build by small communities (or my single developer) and have some applications. But, it&rsquo;s risky to invest in them. You can look into because of curiosity, but not more. As for me it&rsquo;s much safe to use Play/Grails than some unpopular frameworks.</p>

<a name="Summary"></a>
<h2>Summary</h2>

<p>So, Java ecosystem has two full stack frameworks which use Java language minimally: <strong>Grails</strong> (Groovy/Java) and <strong>Play</strong> (Scala/Java). Also, we have a bunch of code generation frameworks and domain-driven frameworks (which occupy really special niche).</p>

<a name="References"></a>
<h2>References</h2>

<ul>
<li>Full stack

<ul>
<li><a href="https://grails.org/">Grails</a></li>
<li><a href="https://www.playframework.com/">Play Framework 2</a></li>
</ul>
</li>
<li>Code Generation

<ul>
<li><a href="http://projects.spring.io/spring-roo/">Spring Roo</a></li>
<li><a href="http://forge.jboss.org/">JBoss Forge</a></li>
<li><a href="http://appfuse.org/">AppFuse</a></li>
<li><a href="https://jhipster.github.io/">JHipster</a></li>
</ul>
</li>
<li>DD Frameworks

<ul>
<li><a href="http://www.openxava.org/">OpenXava</a></li>
<li><a href="http://isis.apache.org/">Apache Isis</a></li>
</ul>
</li>
<li>Others

<ul>
<li><a href="http://www.ninjaframework.org/">Ninja</a></li>
<li><a href="http://javalite.io/">Javalight</a></li>
<li><a href="http://jodd.org/">Jodd</a> and <a href="http://joddframework.org/">Jodd µicro frameworks</a></li>
<li><a href="http://jooby.org/">Jobby</a></li>
<li><a href="https://github.com/airlift/airlift">airlift</a></li>
<li><a href="http://www.web4j.com/">Web4j</a></li>
<li><a href="http://rifers.org/">Rife</a> - dead</li>
</ul>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Download Jars From Maven Central]]></title>
    <link href="http://halyph.com/blog/2015/03/17/how-to-download-jars-from-maven-central/"/>
    <updated>2015-03-17T18:00:00+02:00</updated>
    <id>http://halyph.com/blog/2015/03/17/how-to-download-jars-from-maven-central</id>
    <content type="html"><![CDATA[<center>
<img src="/images/blog/java.png">
<img src="/images/blog/ivy.png">
<img src="/images/blog/maven.png">
</center>


<p>We know how to download Java libraries with it&rsquo;s dependencies (transitive included) via Maven <em>pom.xml</em>, Ant/Ivy <em>build.xml</em> script, Gradle <em>build.gradle</em> script etc.
But what if we need to download them without these scripts.</p>

<p>There are several ways to do this.
Assume that we&rsquo;d like to download <code>spark-core</code> library (<code>groupId=com.sparkjava, artifactId=spark-core, version=2.1</code>) with all dependencies from <a href="http://search.maven.org/#artifactdetails%7Ccom.sparkjava%7Cspark-core%7C2.1%7Cjar">Maven Central</a> into <code>lib</code> folder.</p>

<a name="Use.Maven3.dependency.plugin"></a>
<h2>Use Maven3 dependency plugin</h2>

<p>Here is there variants for lib download:
&#8220;` bash Download library with all dependencies</p>

<a name="Specify.repoUrl..it.s.optional."></a>
<h1>Specify repoUrl (it&rsquo;s optional)</h1>

<p>mvn dependency:get -DrepoUrl=<a href="http://download.java.net/maven/2/">http://download.java.net/maven/2/</a> -DgroupId=com.sparkjava -DartifactId=spark-core -Dversion=2.1</p>

<a name="OR.use.default.repoUrl"></a>
<h1>OR use default repoUrl</h1>

<p>mvn dependency:get -DgroupId=com.sparkjava -DartifactId=spark-core -Dversion=2.1</p>

<a name="OR.use.parameter.artifact.as.groupId:artifactId:version"></a>
<h1>OR use parameter artifact as groupId:artifactId:version</h1>

<p>mvn dependency:get -Dartifact=com.sparkjava:spark-core:2.1
&#8220;`</p>

<p>Now we need to copy just downloaded artifacts in our working directory:
&#8220;` bash Copy jars from local maven repo
mvn dependency:copy-dependencies -f $HOME/.m2/repository/com/sparkjava/spark-core/2.1/spark-core-2.1.pom -DoutputDirectory=$(pwd)/lib</p>

<a name="the.previous.command.doesn.t.copy.spark-core-x.x.jar..that.s.why.we.should.copy.it.manually"></a>
<h1>the previous command doesn&rsquo;t copy spark-core-x.x.jar, that&rsquo;s why we should copy it manually</h1>

<p>cp $HOME/.m2/repository/com/sparkjava/spark-core/2.1/spark-core-2.1.jar $(pwd)/lib
&#8220;`</p>

<a name="Use.standalone.Ivy"></a>
<h2>Use standalone Ivy</h2>

<p>We can use Ivy as standalone jar to download Maven dependencies without creating Ant build file:</p>

<pre><code class="bash"># 1. Download the latest ivy jar (currently it's v.2.4.0)
curl -L -O http://search.maven.org/remotecontent?filepath=org/apache/ivy/ivy/2.4.0/ivy-2.4.0.jar

# 2. Run ivy.jar to retrieve all dependencies
java -jar ivy-2.4.0.jar -dependency com.sparkjava spark-core 2.1 -retrieve "lib/[artifact]-[revision](-[classifier]).[ext]"
</code></pre>

<p>As you can see Ivy downloads approach is much simpler. The only cons (or pros, it depends) that <strong>ivy.jar</strong> should be additionally downloaded.</p>

<a name="Calling.Ivy.from.Groovy.or.Java"></a>
<h2>Calling Ivy from Groovy or Java</h2>

<p>Here I&rsquo;ve decided to store <a href="http://makandracards.com/evgeny-goldin/5817-calling-ivy-from-groovy-or-java">Evgeny&rsquo;s Goldin</a> code snippet as a reference for myself. Programmatic artifacts downloads is not a common operation. It&rsquo;s alway nice to know the general concept how it can be done. Especially when Ivy documentation is not very informative.</p>

<pre><code class="java Groovy snippet of calling Ivy">import org.apache.ivy.Ivy
import org.apache.ivy.core.module.descriptor.DefaultDependencyDescriptor
import org.apache.ivy.core.module.descriptor.DefaultModuleDescriptor
import org.apache.ivy.core.module.id.ModuleRevisionId
import org.apache.ivy.core.resolve.ResolveOptions
import org.apache.ivy.core.settings.IvySettings
import org.apache.ivy.plugins.resolver.URLResolver
import org.apache.ivy.core.report.ResolveReport
import org.apache.ivy.plugins.parser.xml.XmlModuleDescriptorWriter


public File resolveArtifact(String groupId, String artifactId, String version) {
        //creates clear ivy settings
        IvySettings ivySettings = new IvySettings();
        //url resolver for configuration of maven repo
        URLResolver resolver = new URLResolver();
        resolver.setM2compatible(true);
        resolver.setName('central');
        //you can specify the url resolution pattern strategy
        resolver.addArtifactPattern(
            'http://repo1.maven.org/maven2/[organisation]/[module]/[revision]/[artifact](-[revision]).[ext]');
        //adding maven repo resolver
        ivySettings.addResolver(resolver);
        //set to the default resolver
        ivySettings.setDefaultResolver(resolver.getName());
        //creates an Ivy instance with settings
        Ivy ivy = Ivy.newInstance(ivySettings);

        File ivyfile = File.createTempFile('ivy', '.xml');
        ivyfile.deleteOnExit();

        String[] dep = [groupId, artifactId, version]

        DefaultModuleDescriptor md =
                DefaultModuleDescriptor.newDefaultInstance(ModuleRevisionId.newInstance(dep[0],
                dep[1] + '-caller', 'working'));

        DefaultDependencyDescriptor dd = new DefaultDependencyDescriptor(md,
                ModuleRevisionId.newInstance(dep[0], dep[1], dep[2]), false, false, true);
        md.addDependency(dd);

        //creates an ivy configuration file
        XmlModuleDescriptorWriter.write(md, ivyfile);

        String[] confs = ['default'];
        ResolveOptions resolveOptions = new ResolveOptions().setConfs(confs);

        //init resolve report
        ResolveReport report = ivy.resolve(ivyfile.toURL(), resolveOptions);

        //so you can get the jar library
        File jarArtifactFile = report.getAllArtifactsReports()[0].getLocalFile();

        return jarArtifactFile;
}

resolveArtifact( 'log4j', 'log4j', '1.2.16' )
</code></pre>

<a name="References"></a>
<h2>References</h2>

<ul>
<li><a href="http://stackoverflow.com/questions/15450383/using-maven-to-download-dependencies-to-a-directory-on-the-command-line/15456621">Using Maven to download dependencies to a directory on the command line - Stack Overflow</a></li>
<li><a href="http://stackoverflow.com/questions/15598612/simplest-ivy-code-to-programmatically-retrieve-dependency-from-maven-central">Simplest Ivy code to programmatically retrieve dependency from Maven Central - Stack Overflow</a></li>
<li><a href="http://makandracards.com/evgeny-goldin/5817-calling-ivy-from-groovy-or-java">Calling Ivy from Groovy or Java</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maven Flow for Simple App Creation]]></title>
    <link href="http://halyph.com/blog/2015/02/13/maven-flow-for-simple-app-creation/"/>
    <updated>2015-02-13T00:18:30+02:00</updated>
    <id>http://halyph.com/blog/2015/02/13/maven-flow-for-simple-app-creation</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/blog/java.png"></p>

<p>I provided my reflections about <em>&ldquo;Java for Everything&rdquo;</em> in the previous <a href="/blog/2015/02/13/do-we-need-java-for-everything">post</a>.
Here we will review other implementation of this concept.</p>

<p>I have the next concerns about any Java application (big or small):</p>

<ul>
<li>library dependency management must be simple</li>
<li>it&rsquo;s very bad practice to distribute sources along with libraries (dependency management tools must be used instead: Ivy, Maven, Gradle, etc.)</li>
<li>small application might have a little bit different project layout (not equals to traditional Maven layout)</li>
<li>we should be able to setup IDE (in my case <a href="https://www.jetbrains.com/idea/">Intellij IDEA</a>) as quick a possible. I hate editing Java programs in plain text editor</li>
<li>it must be a convenient way to run Java application with different arguments in <em>production</em> and <em>development</em> modes</li>
</ul>


<a name="Use.Case"></a>
<h2>Use Case</h2>

<p>We have to create simple and small REST application based on <a href="https://github.com/perwendel/spark">Spark Java framework</a> (A Sinatra inspired framework for Java).</p>

<p>Here is the source:
&#8220;` java
import static spark.Spark.get;
import static spark.SparkBase.port;</p>

<p>public class App {
    public static void main( String[] args ) throws NumberFormatException {</p>

<pre><code>    for(String arg: args) System.out.printf("&gt; %s", arg);

    get("/hello", (request, response) -&gt; {
        return "Hello World!";
    });
}
</code></pre>

<p>} <br/>
&#8220;`</p>

<p>So, here is the list of issues:</p>

<ul>
<li>get Spark dependency with all transitive dependencies</li>
<li>pass command-line arguments into the app</li>
<li>use this application in development mode and in &ldquo;production&rdquo; (packed in jar)</li>
</ul>


<a name="Traditional.Maven.Way"></a>
<h2>Traditional Maven Way</h2>

<ul>
<li><p>Generate empty project via Maven archetype
<code>bash
mvn archetype:generate \
-DgroupId=com.halyph \
-DartifactId=sparkblog \
-Dpackage=com.halyph.blog \
-Dversion=1.0-SNAPSHOT \
-DarchetypeGroupId=org.apache.maven.archetypes \
-DarchetypeArtifactId=maven-archetype-quickstart \
-DinteractiveMode=false
</code></p></li>
<li><p>Open this in IDEA (I don&rsquo;t use other IDEs) via &ldquo;Open File or Project&rdquo; and select folder with generated <strong>pom.xml</strong> file. We don&rsquo;t need tests, so we can delete <em>src->test</em> folder and remove junit dependency from <strong>pom.xml</strong> file. Now, we can easily run our application via IDE.</p></li>
<li><p>Add Spark framework dependency to <strong>pom.xml</strong> and update our <strong>App</strong> class
&#8220;` xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion></p>

<p><groupId>com.halyph</groupId>
<artifactId>sparkblog</artifactId>
<version>1.0-SNAPSHOT</version>
<packaging>jar</packaging></p>

<p><name>sparkblog</name>
<url><a href="http://maven.apache.org">http://maven.apache.org</a></url></p>

<p><properties>
  &lt;project.build.sourceEncoding>UTF-8&lt;/project.build.sourceEncoding>
</properties></p>

<p><dependencies>
  <dependency>
    <groupId>com.sparkjava</groupId>
    <artifactId>spark-core</artifactId>
    <version>2.1</version>
  </dependency>
</dependencies></p>

<p><build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-compiler-plugin</artifactId>
      <version>3.1</version>
      <configuration>
        <target>1.8</target>
        <source>1.8</source>
      </configuration>
    </plugin>
  </plugins>
</build>
</project>
&#8220;`</p></li>
</ul>


<pre><code class="java">package com.halyph.blog;

import static spark.Spark.get;

public class App {
    public static void main(String[] args) throws NumberFormatException {

        String myArgs = "";
        for (String arg : args) {
            System.out.printf("&gt; %s", arg);
            myArgs += arg + " : ";
        }
        System.out.println();
        final String finalMyArgs = myArgs;
        get("/hello", (request, response) -&gt; {
            return "Hello World!\n args = " + finalMyArgs;
        });
    }
}
</code></pre>

<p>This application can be easily run via IDE, but lets run it via Maven</p>

<ul>
<li>We should use <a href="http://mojo.codehaus.org/exec-maven-plugin/usage.html">Exec Maven Plugin</a> to run the app with all dependencies
&#8220;` bash
$ mvn clean compile exec:java -Dexec.mainClass=&ldquo;com.halyph.blog.App&rdquo;  -Dexec.args=&ldquo;9090 one 1 2&rdquo;
[INFO] Scanning for projects&hellip;
[INFO]
[INFO] &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
[INFO] Building sparkblog 1.0-SNAPSHOT
[INFO] &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
[INFO]
[INFO] &mdash; maven-clean-plugin:2.4.1:clean (default-clean) @ sparkblog &mdash;
[INFO] Deleting d:\MyProjects\jwrapper\bloggg\sparkblog\target
[INFO]
[INFO] &mdash; maven-resources-plugin:2.5:resources (default-resources) @ sparkblog &mdash;
[debug] execute contextualize
[INFO] Using &lsquo;UTF-8&rsquo; encoding to copy filtered resources.
[INFO] skip non existing resourceDirectory d:\MyProjects\sparkblog\src\main\resources
[INFO]
[INFO] &mdash; maven-compiler-plugin:3.1:compile (default-compile) @ sparkblog &mdash;
[INFO] Changes detected - recompiling the module!
[INFO] Compiling 1 source file to d:\MyProjects\jwrapper\bloggg\sparkblog\target\classes
[INFO]
[INFO] >>> exec-maven-plugin:1.2.1:java (default-cli) @ sparkblog >>>
[INFO]
[INFO] &lt;&lt;&lt; exec-maven-plugin:1.2.1:java (default-cli) @ sparkblog &lt;&lt;&lt;
[INFO]
[INFO] &mdash; exec-maven-plugin:1.2.1:java (default-cli) @ sparkblog &mdash;

<blockquote><p>9090> one> 1> 2
[Thread-1] INFO spark.webserver.SparkServer - == Spark has ignited &hellip;
[Thread-1] INFO spark.webserver.SparkServer - >> Listening on 0.0.0.0:4567
[Thread-1] INFO org.eclipse.jetty.server.Server - jetty-9.0.2.v20130417
[Thread-1] INFO org.eclipse.jetty.server.ServerConnector - Started ServerConnector@4afe75c9{HTTP/1.1}{0.0.0.0:4567}
&#8220;`</p></blockquote></li>
</ul>


<p>In case the application run configurations is persistent (&ldquo;main&rdquo; class and CLI arguments are changing rarely) we can configure it in <strong>pom.xml</strong>:
<code>xml
 &lt;build&gt;
    &lt;plugins&gt;
      ...
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;exec-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.3.2&lt;/version&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;goals&gt;
              &lt;goal&gt;java&lt;/goal&gt;
            &lt;/goals&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
        &lt;configuration&gt;
          &lt;mainClass&gt;com.halyph.blog.App&lt;/mainClass&gt;
          &lt;arguments&gt;
            &lt;argument&gt;9090&lt;/argument&gt;
            &lt;argument&gt;one&lt;/argument&gt;
            &lt;argument&gt;1&lt;/argument&gt;
            &lt;argument&gt;2&lt;/argument&gt;
          &lt;/arguments&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
</code></p>

<ul>
<li>It&rsquo;s nice idea to use <code>mvn exec:java</code>, but it might be a little bit slow. So, we might decide to use some shell script which increase compiled application ramp up time. The problem is that the application have dependencies (which have transitive dependencies). I.e. <code>java</code> classpath have to be configured somehow.</li>
</ul>


<p>Well, I borrowed the ideas from &ldquo;<a href="http://saltnlight5.blogspot.com/2012/08/a-better-java-shell-script-wrapper.html">A better java shell script wrapper</a>&rdquo; script. Here it is:
&#8220;` bash</p>

<a name="L..usr.bin.env.bash"></a>
<h1>!/usr/bin/env bash</h1>

<p>#</p>

<a name="Copyright.2012.Zemian.Deng"></a>
<h1>Copyright 2012 Zemian Deng</h1>

<p>#</p>

<a name="A.wrapper.script.that.run.any.Java.application.in.unix.cygwin.bash.env."></a>
<h1>A wrapper script that run any Java application in unix/cygwin bash env.</h1>

<p>#</p>

<a name="This.script.is.assumed.to.be.located.in.an.application.s..bin..directory..It.will"></a>
<h1>This script is assumed to be located in an application&rsquo;s &ldquo;bin&rdquo; directory. It will</h1>

<a name="auto.resolve.its.directory.location.relative.to.the.application.path..which.is.one"></a>
<h1>auto resolve its directory location relative to the application path (which is one</h1>

<a name="parent.up.from.the.script...Therefore..this.script.can.be.run.any.where.in.the.file"></a>
<h1>parent up from the script.) Therefore, this script can be run any where in the file</h1>

<a name="system.and.it.will.still.reference.the.same.application.directory."></a>
<h1>system and it will still reference the same application directory.</h1>

<p>#</p>

<a name="This.script.will.by.default.auto.setup.a.Java.classpath.that.picks.up.any..config."></a>
<h1>This script will by default auto setup a Java classpath that picks up any &ldquo;config&rdquo;</h1>

<a name="and..lib..directories.under.the.application.directory..It.also.will.also.add.a"></a>
<h1>and &ldquo;lib&rdquo; directories under the application directory. It also will also add a</h1>

<a name="any.typical.Maven.project.output.directories.such.as..target.test-classes.."></a>
<h1>any typical Maven project output directories such as &ldquo;target/test-classes&rdquo;,</h1>

<a name="L.target.classes...and..target.dependency..into.classpath..This.can.be.disable.by"></a>
<h1>&ldquo;target/classes&rdquo;, and &ldquo;target/dependency&rdquo; into classpath. This can be disable by</h1>

<a name="setting.RUN_JAVA_NO_AUTOCP.1."></a>
<h1>setting RUN_JAVA_NO_AUTOCP=1.</h1>

<p>#</p>

<a name="If.the..Default.parameters..section.bellow.doesn.t.match.to.user.s.env..then.user"></a>
<h1>If the &ldquo;Default parameters&rdquo; section bellow doesn&rsquo;t match to user&rsquo;s env, then user</h1>

<a name="may.override.these.variables.in.their.terminal.session.or.preset.them.in.shell.s"></a>
<h1>may override these variables in their terminal session or preset them in shell&rsquo;s</h1>

<a name="profile.startup.script..The.values.of.all.path.should.be.in.cygwin.unix.path."></a>
<h1>profile startup script. The values of all path should be in cygwin/unix path,</h1>

<a name="and.this.script.will.auto.convert.them.into.Windows.path.where.is.needed."></a>
<h1>and this script will auto convert them into Windows path where is needed.</h1>

<p>#</p>

<a name="User.may.customize.the.Java.classpath.by.setting.RUN_JAVA_CP..which.will.prefix.to.existing"></a>
<h1>User may customize the Java classpath by setting RUN_JAVA_CP, which will prefix to existing</h1>

<a name="classpath..or.use.the..-cp..option..which.will.postfix.to.existing.classpath."></a>
<h1>classpath, or use the &ldquo;-cp&rdquo; option, which will postfix to existing classpath.</h1>

<p>#</p>

<a name="Usage:"></a>
<h1>Usage:</h1>

<a name="run-java..java_opts...java_main_class...-cp..more.classpath...-Dsysprop.value."></a>
<h1>run-java [java_opts] <java_main_class> [-cp /more/classpath] [-Dsysprop=value]</h1>

<p>#</p>

<a name="Example:"></a>
<h1>Example:</h1>

<a name="run-java.example.Hello"></a>
<h1>run-java example.Hello</h1>

<a name="run-java.example.Hello.-Dname.World"></a>
<h1>run-java example.Hello -Dname=World</h1>

<a name="run-java.org.junit.runner.JUnitCore.example.HelloTest.-cp...HOME.apps.junit.lib..."></a>
<h1>run-java org.junit.runner.JUnitCore example.HelloTest -cp &ldquo;$HOME/apps/junit/lib/*&rdquo;</h1>

<p>#</p>

<a name="Created.by:.Zemian.Deng.03.09.2012"></a>
<h1>Created by: Zemian Deng 03/09/2012</h1>

<a name="This.run.script.dir..resolve.to.absolute.path."></a>
<h1>This run script dir (resolve to absolute path)</h1>

<p>SCRIPT_DIR=$(cd $(dirname $0) &amp;&amp; pwd)    # This dir is where this script live.
APP_DIR=$(cd $SCRIPT_DIR/.. &amp;&amp; pwd)      # Assume the application dir is one level up from script dir.</p>

<a name="Default.parameters"></a>
<h1>Default parameters</h1>

<p>JAVA_HOME=${JAVA_HOME:=$HOME/apps/jdk}     # This is the home directory of Java development kit.
RUN_JAVA_CP=${RUN_JAVA_CP:=$CLASSPATH}     # A classpath prefix before -classpath option, default to $CLASSPATH
RUN_JAVA_OPTS=${RUN_JAVA_OPTS:=}           # Java options (-Xmx512m -XX:MaxPermSize=128m etc)
RUN_JAVA_DEBUG=${RUN_JAVA_DEBUG:=}         # If not empty, print the full java command line before executing it.
RUN_JAVA_NO_PARSE=${RUN_JAVA_NO_PARSE:=}   # If not empty, skip the auto parsing of -D and -cp options from script arguments.
RUN_JAVA_NO_AUTOCP=${RUN_JAVA_NO_AUTOCP:=} # If not empty, do not auto setup Java classpath
RUN_JAVA_DRY=${RUN_JAVA_DRY:=}             # If not empty, do not exec Java command, but just print</p>

<a name="OS.specific.support....var..em.must..em..be.set.to.either.true.or.false."></a>
<h1>OS specific support.  $var <em>must</em> be set to either true or false.</h1>

<p>CYGWIN=false;
case &ldquo;<code>uname</code>&rdquo; in
  CYGWIN*) CYGWIN=true ;;
esac</p>

<a name="Define.where.is.the.java.executable.is"></a>
<h1>Define where is the java executable is</h1>

<p>JAVA_CMD=java
if [ -d &ldquo;$JAVA_HOME&rdquo; ]; then
    JAVA_CMD=&ldquo;$JAVA_HOME/bin/java&rdquo;
fi</p>

<a name="Auto.setup.applciation.s.Java.Classpath..only.if.they.exists."></a>
<h1>Auto setup applciation&rsquo;s Java Classpath (only if they exists)</h1>

<p>if [ -z &ldquo;$RUN_JAVA_NO_AUTOCP&rdquo; ]; then
    if [ -d &ldquo;$APP_DIR/config&rdquo; ]; then RUN_JAVA_CP=&ldquo;$RUN_JAVA_CP:$APP_DIR/config&rdquo; ; fi
    if [ -d &ldquo;$APP_DIR/target/test-classes&rdquo; ]; then RUN_JAVA_CP=&ldquo;$RUN_JAVA_CP:$APP_DIR/target/test-classes&rdquo; ; fi
    if [ -d &ldquo;$APP_DIR/target/classes&rdquo; ]; then RUN_JAVA_CP=&ldquo;$RUN_JAVA_CP:$APP_DIR/target/classes&rdquo; ; fi
    if [ -d &ldquo;$APP_DIR/target/dependency&rdquo; ]; then RUN_JAVA_CP=&ldquo;$RUN_JAVA_CP:$APP_DIR/target/dependency/<em>&rdquo; ; fi
    if [ -d &ldquo;$APP_DIR/lib&rdquo; ]; then RUN_JAVA_CP=&ldquo;$RUN_JAVA_CP:$APP_DIR/lib/</em>&rdquo; ; fi
fi</p>

<p>ARGS=&ldquo;$@&rdquo;</p>

<a name="Parse.addition..-cp..and..-D..after.the.Java.main.class.from.script.arguments"></a>
<h1>Parse addition &ldquo;-cp&rdquo; and &ldquo;-D&rdquo; after the Java main class from script arguments</h1>

<a name="This.is.done.for.convenient.sake.so.users.do.not.have.to.export.RUN_JAVA_CP.and.RUN_JAVA_OPTS"></a>
<h1>This is done for convenient sake so users do not have to export RUN_JAVA_CP and RUN_JAVA_OPTS</h1>

<a name="saparately..but.now.they.can.pass.into.end.of.this.run-java.script.instead."></a>
<h1>saparately, but now they can pass into end of this run-java script instead.</h1>

<a name="This.can.be.disable.by.setting.RUN_JAVA_NO_PARSE.1."></a>
<h1>This can be disable by setting RUN_JAVA_NO_PARSE=1.</h1>

<p>if [ -z &ldquo;$RUN_JAVA_NO_PARSE&rdquo; ]; then
    # Prepare variables for parsing
    FOUND_CP=
    NEW_ARGS[0]=&lsquo;&rsquo;
    IDX=0</p>

<pre><code># Parse all arguments and look for "-cp" and "-D"
for ARG in "$@"; do
    if [[ -n $FOUND_CP ]]; then
        RUN_JAVA_CP="$RUN_JAVA_CP:$ARG"
        FOUND_CP=
    else
        case $ARG in
        '-cp')
            FOUND_CP=1
            ;;
        '-D'*)
            RUN_JAVA_OPTS="$RUN_JAVA_OPTS $ARG"
            ;;
        *)
            NEW_ARGS[$IDX]="$ARG"
            let IDX=$IDX+1
            ;;
        esac
    fi
done
ARGS="${NEW_ARGS[@]}"
</code></pre>

<p>fi</p>

<a name="Convert.Windows.Java.Classpath"></a>
<h1>Convert Windows Java Classpath</h1>

<p>if $CYGWIN; then
    RUN_JAVA_CP=$(cygpath -mp $RUN_JAVA_CP)
fi</p>

<a name="Display.full.Java.command."></a>
<h1>Display full Java command.</h1>

<p>if [ -n &ldquo;$RUN_JAVA_DEBUG&rdquo; ] || [ -n &ldquo;$RUN_JAVA_DRY&rdquo; ]; then
    echo &ldquo;$JAVA_CMD&rdquo; $RUN_JAVA_OPTS -cp &ldquo;$RUN_JAVA_CP&rdquo; $ARGS
fi</p>

<a name="Run.Java.Main.class"></a>
<h1>Run Java Main class</h1>

<p>if [ -z &ldquo;$RUN_JAVA_DRY&rdquo; ]; then
    &ldquo;$JAVA_CMD&rdquo; $RUN_JAVA_OPTS -cp &ldquo;$RUN_JAVA_CP&rdquo; $ARGS
fi
&#8220;`</p>

<p>The main idea is to run <code>mvn dependency:copy-dependencies</code>, this will generate all the jar files into <code>target/dependency</code> folder</p>

<pre><code class="bash">$ mvn dependency:copy-dependencies
[INFO] Scanning for projects...
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] Building sparkblog 1.0-SNAPSHOT
[INFO] ------------------------------------------------------------------------
[INFO]
[INFO] --- maven-dependency-plugin:2.1:copy-dependencies (default-cli) @ sparkblog ---
[INFO] Copying spark-core-2.1.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\spark-core-2.1.jar
[INFO] Copying jetty-http-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-http-9.0.2.v20130417.jar
[INFO] Copying jetty-io-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-io-9.0.2.v20130417.jar
[INFO] Copying jetty-security-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-security-9.0.2.v20130417.jar
[INFO] Copying jetty-server-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-server-9.0.2.v20130417.jar
[INFO] Copying jetty-servlet-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-servlet-9.0.2.v20130417.jar
[INFO] Copying jetty-util-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-util-9.0.2.v20130417.jar
[INFO] Copying jetty-webapp-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-webapp-9.0.2.v20130417.jar
[INFO] Copying jetty-xml-9.0.2.v20130417.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\jetty-xml-9.0.2.v20130417.jar
[INFO] Copying javax.servlet-3.0.0.v201112011016.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\javax.servlet-3.0.0.v201112011016.jar
[INFO] Copying slf4j-api-1.7.7.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\slf4j-api-1.7.7.jar
[INFO] Copying slf4j-simple-1.7.7.jar to d:\MyProjects\jwrapper\bloggg\sparkblog\target\dependency\slf4j-simple-1.7.7.jar
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2.978s
[INFO] Finished at: Thu Feb 12 18:22:54 EET 2015
[INFO] Final Memory: 9M/243M
[INFO] ------------------------------------------------------------------------
</code></pre>

<p>Now, we can reuse the provided <em>above</em> script <strong>or</strong> use the provided <em>below</em> one-liner:
<code>bash
java -cp target\classes;target\dependency\* com.halyph.blog.App 9090 one 1 2
</code>
This one-liner is very simple and can be transformed to shell/batch scripts depending on the level of re-use you&rsquo;d like to implement.</p>

<ul>
<li>Now, it&rsquo;s time to created pre-packed application bundle which can be easily distributed. We will use <a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/usage-program.html">Maven Application Assembler Plugin</a>:
<code>xml
&lt;build&gt;
  &lt;plugins&gt;
   ...
    &lt;plugin&gt;
      &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
      &lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt;
      &lt;version&gt;1.9&lt;/version&gt;
      &lt;!--
      This (executions) section can be omitted.
      In case it's omitted we should call the next command to generate wrapper:
      mvn package appassembler:assemble
      --&gt;
      &lt;executions&gt;
        &lt;execution&gt;
          &lt;phase&gt;package&lt;/phase&gt;
          &lt;goals&gt;
            &lt;goal&gt;assemble&lt;/goal&gt;
          &lt;/goals&gt;
        &lt;/execution&gt;
      &lt;/executions&gt;
      &lt;configuration&gt;
        &lt;programs&gt;
          &lt;program&gt;
            &lt;mainClass&gt;com.halyph.blog.App&lt;/mainClass&gt;
            &lt;id&gt;app&lt;/id&gt;
          &lt;/program&gt;
        &lt;/programs&gt;
      &lt;/configuration&gt;
    &lt;/plugin&gt;
  &lt;/plugins&gt;
&lt;/build&gt;
</code>

<blockquote><p>The Application Assembler Plugin is a Maven plugin for generating scripts for starting java applications. All dependencies and the artifact of the project itself are placed in a generated Maven repository in a defined assemble directory. All artifacts (dependencies + the artifact from the project) are added to the classpath in the generated bin scripts.</p></blockquote></li>
</ul>


<p><a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/usage-program.html">Maven Application Assembler Plugin</a> usage:
<code>bash  
$ mvn package
$ target/appassembler/bin/app
</code></p>

<blockquote><ul>
<li><p>All dependencies and the artifact itself are placed in the defined assemble directory (defaults to <code>$project.build.directory/appassembler</code>).</p></li>
<li><p>A <code>bin/</code> directory is created in the assemble directory and the generated bin scripts are placed in that directory (defaults to both unix shell scripts and Windows bat files).</p></li>
</ul>
</blockquote>

<p>Note: <a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/usage-program.html">Maven Application Assembler Plugin</a> have a lot of customization options, just check the documentation.</p>

<a name="Summary"></a>
<h2>Summary</h2>

<p>Here was shown that using such tool as Maven you can be productive and &ldquo;agile&rdquo; (use <a href="http://gradle.org">Gradle</a> if you&rsquo;d like to be in trend):</p>

<ul>
<li>generate project skeleton from scratch</li>
<li>open it in IDE without ceremony</li>
<li>call the app via Maven plugin</li>
<li>call it as plain CLI application, but with small ceremony (need to run <em>dependency:copy-dependencies</em>)</li>
<li>package the app for further distribution</li>
</ul>


<p>Yes, it&rsquo;s not a simple <em>write-one</em> Java &ldquo;script&rdquo;, but it&rsquo;s flexible enough to feel like it is.</p>

<a name="References"></a>
<h2>References</h2>

<ul>
<li><a href="/blog/2015/02/13/do-we-need-java-for-everything">Do We Need Java for Everything?</a></li>
<li><a href="http://saltnlight5.blogspot.com/2012/08/a-better-java-shell-script-wrapper.html">A better java shell script wrapper</a></li>
<li><a href="http://mojo.codehaus.org/exec-maven-plugin/usage.html">Exec Maven Plugin</a></li>
<li><a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/usage-program.html">Maven Application Assembler Plugin</a></li>
<li><a href="http://blog.plesslweb.ch/post/6628462331/wrapper-script-for-java-command-line-applications">Wrapper Script for Java Command-Line Applications</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Do We Need Java for Everything?]]></title>
    <link href="http://halyph.com/blog/2015/02/13/do-we-need-java-for-everything/"/>
    <updated>2015-02-13T00:18:30+02:00</updated>
    <id>http://halyph.com/blog/2015/02/13/do-we-need-java-for-everything</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/blog/java.png"></p>

<p>Some time ago one guy wrote a post <a href="http://www.teamten.com/lawrence/writings/java-for-everything.html">Java for Everything</a>. The main idea is to use Java even for shell scripting.</p>

<blockquote><p>I’m even taking this to an extreme and using Java for shell scripts. I’ve found that anything other than a simple wrapper shell script eventually grows to the point where I’m looking up the arcane syntax for removing some middle element from an array in bash &hellip; Write it in Java to start with. If shelling out to run commands is clumsy, write a utility function to make it easy.
I’ve also written a <em>java_launcher</em> shell script that allows me to write this at the top of Java programs:
&#8220;` bash</p>

<a name="L..usr.bin.env.java_launcher"></a>
<h1>!/usr/bin/env java_launcher</h1>

<a name="vim:ft.java"></a>
<h1>vim:ft=java</h1>

<a name="lib:.home.lk.lib.teamten.jar"></a>
<h1>lib:/home/lk/lib/teamten.jar</h1>

<p>&#8220;`
I can make the Java programs executable and drop the .java extension. The script strips the header, compiles and caches the class file, and runs the result with the specified jars. It provides one of the big advantages of Python: the lack of build scripts for simple one-off programs.</p></blockquote>

<p>Here is the actual source of <a href="https://github.com/lkesteloot/java_launcher">java_launcher</a>:</p>

<pre><code class="bash">#!/bin/bash

# Put this script in your path and write the following line at the top of an
# executable Java source program:
#
#   #!/usr/bin/env java_launcher
#
# Additional documentation here: https://github.com/lkesteloot/java_launcher

# Quit on error.
set -e

# Get the name of the script, which the shell passes to us automatically.
SOURCE_PATHNAME=$1
if [ "$SOURCE_PATHNAME" = "" ]; then
    echo "java_launcher: Must supply name of script as first argument."
    exit 1
fi

# Skip the script name.
shift

# Compute the MD5 of both the source file and this script.
if [ -f /sbin/md5 ]; then
    # Mac OS/X.
    SUM=$(cat "$SOURCE_PATHNAME" $0 | md5)
else
    # Linux.
    SUM=$(cat "$SOURCE_PATHNAME" $0 | md5sum | cut -d' ' -f1)
fi
SOURCE_FILENAME=$(basename "$SOURCE_PATHNAME")
SOURCE_DIR=$(dirname "$SOURCE_PATHNAME")
CLASS_NAME=$(echo $SOURCE_FILENAME | sed -e 's/\.*//')
CACHE_DIR=$HOME/.java_launcher_cache
CLASS_DIR=$CACHE_DIR/$SUM
PROCESSED_SOURCE=$CLASS_DIR/${SOURCE_FILENAME}.java
PROCESSED_CLASS=$CLASS_DIR/${SOURCE_FILENAME}.class

# Process source to find libs for classpath. Relative jars are made relative to the
# source file.
export CLASSPATH=$(awk 'BEGIN { CLASSPATH="" } /^# lib:(.*)$/ { jar = substr($0, 7); if (substr(jar, 1, 1) != "/") jar = SOURCE_DIR "/" jar; if (CLASSPATH != "") CLASSPATH = CLASSPATH ":"; CLASSPATH = CLASSPATH jar } END { print CLASSPATH }' SOURCE_DIR="$SOURCE_DIR" &lt; "$SOURCE_PATHNAME")

# Default libraries. Put default ones last.
SCRIPT_DIR=$(dirname $0)
LIB_DIR=$SCRIPT_DIR/java_lib
export CLASSPATH=$CLASSPATH:$LIB_DIR/\*

# Compile if necessary.
if [ -f "$PROCESSED_CLASS" ]; then
    # Refresh the dir so that we know we've used it recently.
    touch "$CLASS_DIR"
else
    mkdir -p "$CLASS_DIR"

    # Remove header. That's anything that starts with #. Replace the lines with
    # an empty line so the line numbers don't get thrown off.
    sed -e 's/^#.*//' &lt; "$SOURCE_PATHNAME" &gt; "$PROCESSED_SOURCE"

    # Compile real source to our cache.
    javac -d "$CLASS_DIR" "$PROCESSED_SOURCE"
fi

# Run the program, passing on arguments from command line.
export CLASSPATH=$CLASS_DIR:$CLASSPATH
java -Xmx1024m $CLASS_NAME $*
</code></pre>

<p>And suppose we&rsquo;d like to run <strong>helloworld</strong> Java &ldquo;script&rdquo; using different jars located in default library location (<strong>java_lib/</strong>) and custom (<strong>/home/username/mylib1.jar</strong> and <strong>/home/username/mylib2.jar</strong>)</p>

<pre><code class="bash">#!/usr/bin/env java_launcher
# vim:ft=java
# lib:/home/username/mylib1.jar:/home/username/mylib2.jar

public class helloworld {
    public static void main(String[] args) {
        System.out.println("Hello world!");
    }
}
</code></pre>

<p>It can be run like this: <code>$ ./helloworld</code></p>

<a name="So..how.does.java_launcher.work."></a>
<h3>So, how does java_launcher work?</h3>

<ol>
<li>This launcher script works on Linux/MacOSX only. We should have additional <strong>java_launcher.bat</strong> script for Windows (cygwin and msys are not native Windows solution).</li>
<li>It supports two types of CLASSPATH lib folders</li>
<li><em>default</em> <strong>$SCRIPT_DIR/java_lib</strong> located in the same folder where the actual Java script located</li>
<li><em>custom</em> libs, they should be listed at the head <strong>lib</strong> section of the script (see sample above). The script uses AWK to extract jars from <strong>lib</strong> section</li>
<li><strong>java_launcher</strong> uses MD5 hashing to track source changes and (re)compile the source script only when it has been changed. See MD5 calculated <code>SUM</code> variable above</li>
<li><em>launcher</em> has dedicated folder where it stores the processed and compiled script (based on MD5 hash changes). See the next variables: <code>CACHE_DIR</code>, <code>PROCESSED_SOURCE</code> and <code>PROCESSED_CLASS</code>.</li>
<li>Then it combines the <em>default</em> and <em>custom</em> libs in resulted CLASSPATH</li>
</ol>


<a name="Drawbacks"></a>
<h3>Drawbacks</h3>

<p>I see the next drawbacks:
- libs should be distributed along with actual &ldquo;script&rdquo;. The common use case is to have minimal required script, which downloads all required dependencies by yourself
- launcher is not cross-platform
- Java script requires additional configuration to be opened/edited in IDE (project file, adjust all dependencies, etc.)
- it&rsquo;s very hard to edit Java code in plain editor (Java language is verbose). Scripting in Java without IDE might be real pain</p>

<a name="Why.not.Groovy."></a>
<h2>Why not Groovy?</h2>

<p>I don&rsquo;t think that Java is &ldquo;good&rdquo; language for scripting (see drawbacks above). Groovy is much better language with nice scripting capabilities. Every Groovy script might be treated like a Java code snippet (with some exceptions <a href="http://groovy.codehaus.org/Differences+from+Java">[1]</a> and <a href="http://groovy-lang.org/differences.html">[2]</a>). But, the most important is that Groovy has build-in <a href="http://groovy-lang.org/grape.html">Grape dependency manager</a>:</p>

<blockquote><p>Grape (The Groovy Adaptable Packaging Engine or Groovy Advanced Packaging Engine) is the infrastructure enabling the grab() calls in Groovy, a set of classes leveraging Ivy to allow for a repository driven module system for Groovy. This allows a developer to write a script with an essentially arbitrary library requirement, and ship just the script. Grape will, at runtime, download as needed and link the named libraries and all dependencies forming a transitive closure when the script is run from existing repositories such as JCenter, Ibiblio, Codehaus, and java.net.</p></blockquote>

<p>Sample usage:
<code>groovy
@Grapes([
   @Grab(group='commons-primitives', module='commons-primitives', version='1.0'),
   @Grab(group='org.ccil.cowan.tagsoup', module='tagsoup', version='0.9.7')])
class Example {
// ...
}
</code></p>

<blockquote><p>One or more <code>groovy.lang.Grab</code> annotations can be added at any place that annotations are accepted to tell the compiler that this code relies on the specific library. This will have the effect of adding the library to the classloader of the groovy compiler. This annotation is detected and evaluated before any other resolution of classes in the script, so imported classes can be properly resolved by a @Grab annotation.</p></blockquote>

<p><strong>So, I have no idea why to reinvent the wheel.</strong> Use Groovy for scripting and Java for everything else.</p>

<a name="References"></a>
<h2>References</h2>

<ul>
<li><a href="http://www.teamten.com/lawrence/writings/java-for-everything.html">Java for Everything</a></li>
<li>Some reflections to the original post <a href="http://www.teamten.com/lawrence/writings/java-for-everything.html">Java for Everything</a>:

<ul>
<li><a href="https://news.ycombinator.com/item?id=8677556">Hacker News</a></li>
<li><a href="http://www.reddit.com/r/programming/duplicates/2nvybk/java_for_everything">Reddit</a></li>
</ul>
</li>
<li><a href="https://github.com/lkesteloot/java_launcher">java_launcher</a> source code</li>
<li><a href="http://groovy.codehaus.org/Differences+from+Java">Groovy Differences from Java</a></li>
<li><a href="http://groovy-lang.org/grape.html">Grape dependency manager</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Generate PermGen Leak?]]></title>
    <link href="http://halyph.com/blog/2015/02/05/how-to-generate-permgen/"/>
    <updated>2015-02-05T00:05:30+02:00</updated>
    <id>http://halyph.com/blog/2015/02/05/how-to-generate-permgen</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/blog/java.png"></p>

<p>I&rsquo;m sure that a lot of Java developers experienced <code>java.lang.OutOfMemoryError: PermGen space</code> (OOME PermGen). It was very common to get this error after multiple WAR re-deploys on Tomcat v.6.x. Permanent generation (PermGen) region of memory is used to store the internal representation of loaded classes (and much more, see here [<a href="https://plumbr.eu/blog/what-is-a-permgen-leak">1</a>] and [<a href="https://blogs.oracle.com/jonthecollector/entry/presenting_the_permanent_generation">2</a>]).</p>

<p>So, we can get <strong>OOME PermGen</strong> when ClassLoader whats to store class definition, but there is not enough space in PermGen - i.e. loaded too many classes.</p>

<p>Based on this <strong>OOME PermGen</strong> error can be generated via:</p>

<ul>
<li>decreasing PermGen size</li>
<li>loading huge amount of classes</li>
</ul>


<p>I highly recommend to read <a href="https://plumbr.eu/blog/what-is-a-permgen-leak">What is a PermGen leak?</a> post to get more info about this issue.</p>

<a name="Disclaimer"></a>
<h3>Disclaimer</h3>

<p>The current post is totally based on <a href="https://plumbr.eu/blog/how-not-to-create-a-permgen-leak">How (not) to create a permgen leak?</a></p>

<a name="Generate.PermGen.leak"></a>
<h2>Generate PermGen leak</h2>

<p>The main idea is dynamically create a lot of classes via byte code manipulation library. We are going to use <a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/">Javassist</a> as it&rsquo;s the simplest library with nice API.</p>

<ul>
<li>We assume that it&rsquo;s <code>maven</code> based project. So, let&rsquo;s add Javassist to <code>pom.xml</code>.</li>
</ul>


<pre><code class="xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.mycompany.app&lt;/groupId&gt;
  &lt;artifactId&gt;my-app&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;packaging&gt;jar&lt;/packaging&gt;

  &lt;name&gt;my-app&lt;/name&gt;
  &lt;url&gt;http://maven.apache.org&lt;/url&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;skipTests&gt;true&lt;/skipTests&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.javassist&lt;/groupId&gt;
      &lt;artifactId&gt;javassist&lt;/artifactId&gt;
      &lt;version&gt;3.15.0-GA&lt;/version&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;plugins&gt;
      &lt;plugin&gt;
        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
        &lt;artifactId&gt;appassembler-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.9&lt;/version&gt;
        &lt;configuration&gt;
          &lt;extraJvmArguments&gt;-XX:PermSize=2M -XX:MaxPermSize=4M&lt;/extraJvmArguments&gt;
          &lt;programs&gt;
            &lt;program&gt;
              &lt;mainClass&gt;com.mycompany.app.App&lt;/mainClass&gt;
              &lt;id&gt;app&lt;/id&gt;
            &lt;/program&gt;
          &lt;/programs&gt;
        &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
&lt;/project&gt;
</code></pre>

<ul>
<li>Also, we should set <strong>PermGen</strong> and <strong>MaxPermGen</strong> size to 2M and 4M respectively (it gives us a chance to get error as quickly as possible). Maven <code>Appassembler</code> plugin [<a href="http://mojo.codehaus.org/appassembler/appassembler-maven-plugin/usage-program-jvmsettings.html">3</a>] uses <code>extraJvmArguments</code> parameter while generating wrapper scripts: shell and batch (see <code>pom.xml</code> above, <code>&lt;extraJvmArguments&gt;-XX:PermSize=2M -XX:MaxPermSize=2M&lt;/extraJvmArguments&gt;</code>).</li>
</ul>


<blockquote><p>&ndash;XX:PermSize<size> - Set initial PermGen Size</p>

<p>&ndash;XX:MaxPermSize<size> - Set the maximum PermGen Size</p></blockquote>

<ul>
<li>Below is a simple application which dynamically creates 1000 classes to cause PermGem leak. Class creation is very simple and self explanatory. The main idea is that we should use byte code manipulation library to create classes dynamically.</li>
</ul>


<p>See additional comments in the next code snippet</p>

<pre><code class="java">package com.mycompany.app;

import javassist.CannotCompileException;
import javassist.ClassPool;

import java.util.concurrent.TimeUnit;

/**
 * Steps to build and run demo application: &lt;br /&gt;
 *
 * &lt;li&gt;mvn clean package appassembler:assemble
 * &lt;li&gt;target/appassembler/bin/app
 *
 */
public class App {
    /**
     * We should use static block for OutOfMemoryError "initialization"
     * It's very important to have it. In other case JVM won't be able to
     * throw (actually create new OutOfMemoryError) this exception because
     * there will be no free memory for this. That's why we creating it beforehand.
     * As you can see we intentionally added output to highlight that THIS error
     * was produces by us.
     */
    static {
        new OutOfMemoryError().printStackTrace();
        try {
            TimeUnit.SECONDS.sleep(1);
            System.out.println("=====================");
            System.out.println("Initialized/created OutOfMemoryError");
            System.out.println("=====================");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) throws Exception {
        System.out.println("Start dynamic class creation.....\n");
        for (int i = 0; i &lt; 1000; i++) {
            Class clazz = createClass("MyClass" + i);
            // we use this output as indicator to see the rough number of created classes
            // it's not necessary to print every single (just created) class
            if(i % 50 == 0) System.out.println(clazz);
        }
    }

    private static Class createClass(String className) throws CannotCompileException {
        ClassPool pool = ClassPool.getDefault();
        return pool.makeClass(className).toClass();
    }
}
</code></pre>

<ul>
<li>Run the application</li>
</ul>


<pre><code>$ mvn clean package appassembler:assemble
$ target/appassembler/bin/app
java.lang.OutOfMemoryError
    at com.mycompany.app.App.&lt;clinit&gt;(App.java:15)
=====================
Initialized/created OutOfMemoryError
=====================
Start dynamic class creation.....

class MyClass0
class MyClass50
class MyClass100
class MyClass150
class MyClass200
class MyClass250
class MyClass300
class MyClass350
class MyClass400
class MyClass450
class MyClass500
class MyClass550
Exception in thread "Reference Handler" java.lang.OutOfMemoryError: PermGen space
    at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:140)
Exception in thread "main" java.lang.OutOfMemoryError: PermGen space
    at javassist.ClassPool.toClass(ClassPool.java:1089)
    at javassist.ClassPool.toClass(ClassPool.java:1032)
    at javassist.ClassPool.toClass(ClassPool.java:990)
    at javassist.CtClass.toClass(CtClass.java:1125)
    at com.mycompany.app.App.createClass(App.java:36)
    at com.mycompany.app.App.main(App.java:29)
</code></pre>

<p>The next command runs under the hood:
<code>java -XX:PermSize=2M -XX:MaxPermSize=4M -classpath "$CLASSPATH" com.mycompany.app.App</code></p>

<p>As you can see it was possible to create about 550 <code>MyClass</code> classes before we&rsquo;ve got an expected error.</p>

<a name="Tomcat.Leaks"></a>
<h3>Tomcat Leaks</h3>

<p>Tomcat team created a nice <a href="http://wiki.apache.org/tomcat/MemoryLeakProtection">wiki page</a> where listed and shown the situations where leaks can be detected and fixed.</p>

<a name="References"></a>
<h2>References</h2>

<ul>
<li><a href="https://plumbr.eu/blog/what-is-a-permgen-leak">What is a PermGen leak?</a></li>
<li><a href="https://plumbr.eu/blog/how-not-to-create-a-permgen-leak">How (not) to create a permgen leak?</a></li>
<li><a href="http://www.infoq.com/articles/Java-PERMGEN-Removed">Where Has the Java PermGen Gone?</a> PermGen is replace with Metaspace in Java 8</li>
<li><a href="https://blogs.oracle.com/jonthecollector/entry/presenting_the_permanent_generation">Presenting the Permanent Generation</a> General intro into the subject</li>
<li><a href="http://www.javaranch.com/journal/200711/creating_java_classes_runtime_expression_evaluation.html">Javassist - Creating Java classes at runtime for evaluating numerical expressions</a> Small article how to create Java classes dynamically</li>
<li><a href="http://wiki.apache.org/tomcat/MemoryLeakProtection">Tomcat Wiki MemoryLeakProtection</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
