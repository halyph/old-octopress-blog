<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Languages | Knowledge Is Everything]]></title>
  <link href="http://halyph.com/blog/categories/languages/atom.xml" rel="self"/>
  <link href="http://halyph.com/"/>
  <updated>2015-09-28T03:13:38+03:00</updated>
  <id>http://halyph.com/</id>
  <author>
    <name><![CDATA[Orest Ivasiv]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[About Learning New Programming Languages]]></title>
    <link href="http://halyph.com/2014/01/about-learning-new-programming-languages.html"/>
    <updated>2014-01-26T13:25:00+02:00</updated>
    <id>http://halyph.com/2014/01/about-learning-new-programming-languages</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/posts/progLanguages_small.gif"></p>

<p>This post is very subjective and reflect the my current point of view.</p>

<p>There are tons of different programming
languages. Few of them you are using daily, few of them from time to
time. And huge amount are touched “accidentally” (via playing and
writing “big” hello world).</p>

<p>Now the question is: Should we spend our
time playing with every hipster/hype language? Maybe it’s better to
invest own time in something really important. In something which can
improve our productivity and range of task which can be solved by our
“major” language(s).</p>

<p>In general to “learn” a new language is
not a big deal. But, nowadays we can’t use language itself in
isolation. “Learn a new language” means not only language, but also
its <strong>related areas</strong>:</p>

<ul>
<li>ecosystem (libraries, frameworks,
IDE, tools)</li>
<li>problems which can be solved with
this language (some languages are well suited for the particular set
of problems: Erlang, Prolog, SQL, etc.)</li>
<li>community</li>
<li>best practices and
idiomatic code</li>
<li>etc.</li>
</ul>


<p>Now, if you calculate and recall your
experience You will notice that language <strong>related areas</strong> take huge
amount of time to master.</p>

<p>Here is some general sample: Imagine
that language X is your major tool for making money. Now, you’ve
switched, temporary, to language Y, for reasonable amount of time
(several months). Then you switched back to language X and stick there
for long-long period of time. You will notice how you are loosing those
minimal knowledge (required to accomplish the tasks) gained for language
Y. You can recollect the syntax, but related areas of language Y
have been evolved and updated. Even more, some related areas are
obsolete, etc. And now it will be much hard to get the same knowledge in
language Y quickly. You must be adequate to understand this.</p>

<p><strong>So, what does it mean from me:</strong></p>

<ul>
<li>Select minimal required set of
programming languages which makes you as productive as possible.
Master these languages</li>
<li>It’s a good idea to spend
time playing with other languages. But it’s bad idea to switch from
one to another language regularly. You are losing focus.</li>
<li>Master ecosystem</li>
<li>Be active in language
community</li>
</ul>


<p>I don’t want to say that learning new
languages is a bad idea. No. I don’t think so. But the reality has some
influence on us. It might happen that “new” language and related areas
are cool, you are happy using all these stuff working on pet-projects.
But you have some objective constrains and can’t use it at your work:
e.g. a) there are no projects where you can use this language or b) you
can’t change the company because of geographical constrains. Keeping all
these in mind you should spend your time effectively and learn
really valuable stuff. <br/>
Try to avoid hipster <a href="http://en.wikipedia.org/wiki/Bandwagon_effect">bandwagon effect</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[My Reflection on "Programming Achievements: How to Level Up as a Developer"]]></title>
    <link href="http://halyph.com/blog/2011/08/15/recently-ive-read-amazing-blog-post/"/>
    <updated>2011-08-15T00:52:00+03:00</updated>
    <id>http://halyph.com/blog/2011/08/15/recently-ive-read-amazing-blog-post</id>
    <content type="html"><![CDATA[<p>Recently, I&rsquo;ve read an amazing blog post <a href="http://jasonrudolph.com/blog/2011/08/09/programming-achievements-how-to-level-up-as-a-developer/">&ldquo;Programming Achievements: How to Level Up as a Developer&rdquo;</a>. Also, it worth to read comments to this post, they are really interesting, subjective and personal. But, in any case you&rsquo;ll get something to think about. How to measure your own professional achievements, different ways for improvements and some start point for planning all these stuff.<br /><br />The author suggests to use GitHub Gist as a natural way of improvements to keep them tracking. So, I&rsquo;ve just forked his gist and performed several initial changes (see <a href="https://gist.github.com/1141765"><a href="https://gist.github.com/1141765">https://gist.github.com/1141765</a></a>):<br /><br /><script src="https://gist.github.com/1141765.js?file=programming-achievements.md"></script></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Choose the Next Programming Language to Learn?]]></title>
    <link href="http://halyph.com/blog/2011/02/11/how-to-choose-next-programming-language/"/>
    <updated>2011-02-11T00:50:00+02:00</updated>
    <id>http://halyph.com/blog/2011/02/11/how-to-choose-next-programming-language</id>
    <content type="html"><![CDATA[<p>I believe that this question has been appearing in the brains very often.<br /><i>Note</i>: I&rsquo;m writing from Java developer point of view.<br /><br />How to solve this dilemma? I said &ldquo;dilemma&rdquo; because it&rsquo;s investment in the new knowledge. And every new knowledge should bring some benefits. The wrong investment is equal to waste of your time.<br /><br />As a Java developer I think I should invest outside the JVM. It&rsquo;s even more important in nowadays. Oracle is more aggressive then Sun was. So, investment in non-JVM &ldquo;platform&rdquo;/language can protect the own future.<br /><br />I don&rsquo;t want to write about some definite language. It&rsquo;s not important right now. The most important thing is to learn something new which is totally separated from JVM.<br /><br />Someone can say: &ldquo;Try Groovy, Scala or Clojure&rdquo;. Good point. But,&nbsp; it&rsquo;s JVM (even if they are &ldquo;beautiful&rdquo; and interesting choices). One exception: you can have a possibility to use these languages on the job project. In that case it&rsquo;s ok. Just pick the right one and start the party. In other case avoid them.<br /><br />There is NO right answer. Just define your own philosophy (language to learn) and keep it alive.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Review: Language Grubbing]]></title>
    <link href="http://halyph.com/blog/2011/01/26/review-language-grubbing/"/>
    <updated>2011-01-26T02:58:00+02:00</updated>
    <id>http://halyph.com/blog/2011/01/26/review-language-grubbing</id>
    <content type="html"><![CDATA[<p>Yet another interesting reading from Steve Yegge: <a href="http://sites.google.com/site/steveyegge2/language-grubbing">Language Grubbing</a>.<br /><br />He reviewed several programming languages (C, C++, Java, Perl, Python, Ruby, Smalltalk, Lisp family, ML family, Haskell, Erlang). He mentioned pros and cons for each of them, criticized some of them (Perl, Common Lisp). Also told that Lua, Tcl, Prolog, Pascal wouldn&rsquo;t be in his learning &ldquo;backlog&rdquo;.<br /><blockquote><br />I looked at a lot of other languages: JavaScript, Lua, Tcl, Prolog, Eiffel, Pascal, and a bunch of others. None of them really stood out as being &ldquo;special&rdquo; like the others I&rsquo;ve talked about.<br /><br />For instance, you can do Prolog-like logic/constraint programming in Lisp or OCaml pretty easily, and they&rsquo;re both broader/better languages than Prolog. Pascal gives you nothing that C doesn&rsquo;t already do better. &hellip; Lua is a cleaned-up Tcl, but neither one of them is as interesting (to me, anyway) as Python for doing embedded languages, unless you really need to strip it down to practically nothing, in which case Lua is useful. </blockquote><br />IMHO, reasonable comments. <br />He mentioned about language groups:<br /><ul><li>Java, C# and C++ (<i>I would add Objective-C and Smalltalk</i>)</li><li> Haskell, SML, OCaml (<i>I would add F#, Scala</i>)</li><li>Common Lisp, Emacs Lisp, Scheme (<i>I would add Clojure</i>)</li><li>Perl, Python, Ruby (I would add PHP) </li><li>Erlang (<i>I would add Prolog, Oz</i>)</li><li>Lua, Tcl, JavaScript (<i>I would add Io, Ioke, R, REBOL</i>)</li><li>C, Pascal</li></ul><br />I wrote about this but I&rsquo;ll repeat again. I time wasting if you learn several languages from the same group. E.g. Python and Ruby, or Java and C#.<br />So, just a pick the &ldquo;major&rdquo; language from each group and learn it. E.g.: Java, Haskell, Clojure, Ruby, JavaScript and C.<br /><br /><b>C </b>language is like Latin for the plain developer. <b>JavaScript </b>is must be know by anyone involved in web-related development.<br /><br />For myself I formed the next language priority list:<br /><ol><li>Java </li><li>JavaScript</li><li>Ruby or Python (I haven&rsquo;t decided yet)</li><li>Clojure, Scheme or Common Lisp (I haven&rsquo;t decided yet)</li><li>C</li></ol></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Review: How to Become a Hacker?]]></title>
    <link href="http://halyph.com/blog/2011/01/10/review-how-to-become-hacker/"/>
    <updated>2011-01-10T23:53:00+02:00</updated>
    <id>http://halyph.com/blog/2011/01/10/review-how-to-become-hacker</id>
    <content type="html"><![CDATA[<div class="separator" style="clear: both; text-align: left;"></div>


<div style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;">
    <a href="http://2.bp.blogspot.com/_vLotBlgiVfE/TSt38br1t5I/AAAAAAAAAa0/TdFtyUtBKRo/s1600/glider.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://2.bp.blogspot.com/_vLotBlgiVfE/TSt38br1t5I/AAAAAAAAAa0/TdFtyUtBKRo/s1600/glider.png" /></a>Recently I&#8217;ve read these philosophical essays:<a href="http://www.catb.org/esr/faqs/hacker-howto.html">  How To Become A Hacker, by Eric Steven Raymond</a> and <a href="http://norvig.com/21-days.html">Teach Yourself Programming in Ten Years, by Peter Norvig.</a></div>


<p><br />
<br />It&rsquo;s worth reading. I think that it&rsquo;s like hacker &ldquo;mantra&rdquo; ;-) I don&rsquo;t want to retell all that stuff. Just want to sum up.
<br />
<br /><span style="font-size: large;">1. Programming language learning. </span>
<br />We should learn different programming languages from paradigm point of view: &ldquo;classical&rdquo; OOP languages (C++, C#, Java), procedural languages &copy;, functional languages (Lisp family languages: Common Lisp, Scheme, Clojure), dynamic and scripting languages (Perl, Python, Ruby) and web-related (JavaScript).
<br /></p>

<blockquote><i>&#8220;Besides being the most important &#8230; languages, they represent very different approaches to programming, and each will educate you in valuable ways.&#8221;</i></blockquote>


<p>It means that you should&nbsp; learn languages from different paradigms to get some conceptual&nbsp; knowledge.
<br /><i>E.g. </i>You shouldn&rsquo;t learn Java and&nbsp; C#, or Python and Ruby. I think it&rsquo;s just waste of your time.
<br /></p>

<blockquote><b><i>&#8220;To be a real hacker, you need to get to the point where you can learn a new language in days by relating what&#8217;s in the manual to what you already know.This means you should learn several very different languages.&#8221;</i></b></blockquote>


<p><span style="font-size: large;">2. Learn Unix/Linux.</span>
<br /><span style="font-size: small;">I think the best way to learn is to start playing with Ubuntu.</span>
<br />
<br /><span style="font-size: small;"><span style="font-size: large;">3. Learn English and native language.&nbsp;</span> </span>
<br /><span style="font-size: small;">You should be able the speak and write </span>fluently in both.
<br />
<br /><span style="font-size: large;">4. Persistent learning </span>
<br /><span style="font-size: small;">It&rsquo;s the key point to success in any profession.</span>
<br />
<br />
<br /><span style="font-size: large;">Summary</span>
<br /></p>

<blockquote><i>&#8220;To follow the path:</i>
    <br /><i>look to the master,</i>
    <br /><i>follow the master,</i>
    <br /><i>walk with the master,</i>
    <br /><i>see through the master,</i>
    <br /><i>become the master.&#8221;</i></blockquote>

]]></content>
  </entry>
  
</feed>
