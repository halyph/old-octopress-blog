---
layout: post
title: Lisp, Ruby, Acceptable and not Acceptable
date: '2011-01-22T17:10:00.001+02:00'
author: Orest Ivasiv
tags:
- ruby
- vs
- Lisp
modified_time: '2011-01-22T17:14:09.353+02:00'
thumbnail: http://2.bp.blogspot.com/_vLotBlgiVfE/TTryfUy5UwI/AAAAAAAAAbA/1e6SWfopmQw/s72-c/media_httpwwwdeimeken_rvzBA.gif.scaled661.gif
blogger_id: tag:blogger.com,1999:blog-7372777165432727866.post-4295332052819420185
blogger_orig_url: http://www.halyph.com/2011/01/lisp-ruby-acceptable-and-not-acceptable.html
---

There is one really (in)famous essay <a href="http://www.randomhacks.net/articles/2005/12/03/why-ruby-is-an-acceptable-lisp">Why Ruby is an acceptable LISP</a> by Eric Kidd. The most interesting of all this stuff are comments and other responsive blog posts (e.g. <a href="http://steve-yegge.blogspot.com/2006/04/lisp-is-not-acceptable-lisp.html">Lisp is Not an Acceptable Lisp</a> by Steve Yegge)<br />I can say this is something like "vs" essay which is very popular nowadays. <br /><br />Here is the list of some quotes and key ideas:<br /><br /><ul><li>Lisp macros are far more powerful than the trivial use cases you’ve listed. I could give a lot of examples here, but just ask yourself: why is most of the programming community so fond with “Design Patterns”, while the Lisp community generally isn’t? <b>Well, that’s because patterns are nothing but high-level specifications for code being rewritten again and again and again. The Lisp approach is to create some macros and auxiliary functions that actually implement the pattern, thus extending the language capabilities and avoiding continuous reinvention of the wheel.</b></li><li>This article sounds like it was written for folks who really want to use Lisp, but have chosen Ruby because all the<i> cool kids</i> are using it and want to reasonably justify an emotional decision. </li><li>If you want to learn a language that can change with the times and incorporate whatever latest fad the programming cool kids have to offer, Lisp is the choice. Lisp is the red pill.</li><li>A final example: look at the 2 open source Computer Algebra Systems written in Common Lisp available as Open Source: 1) Axiom – originally from IBM Thomas Watson Research Center; 2) Maxima – originally Department of Energy (US). This is software written in the 70s. You can’t write software that lasts so long with a language that is a moving target. This is the kind of survival and complex domain which shows the power of Lisp.</li><li>The real reason that brought me to Lisp (and never will get me away from it) is simply this:<br />You can build it out of 7 (s-e-v-e-n) primitive operators!<br />And, as a consequence, no other language can be expressed in itself as short as Lisp. (As you probably know, quite any language can be expressed in itself.)<br />So let me repeat: <b>really no other language can be expressed in itself that short, and (as a natural consequence) can be built out of less primitive operators.</b><br /></li><li>Ruby has a syntax, and Ruby needs a full parser to get from that syntax to an AST. Because Lisp code is naturally an AST, things are very different</li></ul>And small summary of the Steve's blog post <a href="http://steve-yegge.blogspot.com/2006/04/lisp-is-not-acceptable-lisp.html">Lisp is Not an Acceptable Lisp</a>:<br /><blockquote>There is no acceptable Lisp. This is a problem. It's not a little teeny one, either. The Lisp communities (yeah, there are a bunch) are going to have to realize that if Lisp is ever going to be massively successful, it needs an overhaul. Or maybe a revolution. Contrary to what some might tell you, it doesn't need a committee, and it doesn't need a bunch of money. Linux proved exactly the opposite. <span style="font-size: x-large;">Lisp needs a benevolent dictator</span>. Lisp needs to ditch the name "Lisp", since it scares people. And Lisp needs to learn from the lessons of the 45 years of languages that have followed it.</blockquote>Based on this comments and I'm attaching this funny picture:<br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="http://2.bp.blogspot.com/_vLotBlgiVfE/TTryfUy5UwI/AAAAAAAAAbA/1e6SWfopmQw/s1600/media_httpwwwdeimeken_rvzBA.gif.scaled661.gif" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="640" src="http://2.bp.blogspot.com/_vLotBlgiVfE/TTryfUy5UwI/AAAAAAAAAbA/1e6SWfopmQw/s640/media_httpwwwdeimeken_rvzBA.gif.scaled661.gif" width="288" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;"><a href="http://danelliott.me/the-programmers-superiority-complex-in-hierar">The programmer's superiority complex... in hierarchy format.</a></td></tr></tbody></table>